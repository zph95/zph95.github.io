{
    "layout": "verticalTimeline",
    "root": {
        "data": {
            "text": "<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 24px;\n      font-weight: bold;\n      font-style: normal;\n      text-decoration: none\n    \">Java开发工程师</span></p>",
            "note": "<div>梦开始的地方</div>",
            "richText": true,
            "expand": true,
            "isActive": false,
            "uid": "51ada305-6d25-4e4d-8de4-cb85977a19d4"
        },
        "children": [
            {
                "data": {
                    "text": "<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Object类</span></p>",
                    "richText": true,
                    "expand": true,
                    "isActive": false,
                    "uid": "2332b59e-9209-434b-ae3e-e9f225341517"
                },
                "children": [
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">主要方法</span></p>",
                            "note": "<div>Java中的Object类是所有类的根类，它定义了一些基本的方法，这些方法可以被所有Java对象继承和使用。下面是Object类的主要方法：</div><ol><li>equals(Object obj)：用于比较当前对象和另一个对象是否相等。默认情况下，它比较的是对象的引用是否相等，但是可以在子类中重写该方法来实现自定义的相等逻辑。</li><li>hashCode()：返回对象的哈希码值。哈希码在散列数据结构中非常有用，比如在使用HashMap或HashSet等集合类时会用到。</li><li>toString()：返回对象的字符串表示。默认情况下，它返回一个由类名、@符号和对象的哈希码组成的字符串。可以在子类中重写该方法来返回更有意义的字符串表示。</li><li>getClass()：返回对象的运行时类。该方法返回一个Class对象，它包含有关类的信息，比如类的名称、字段、方法等。</li><li>clone()：创建并返回当前对象的副本。该方法会创建一个新的对象，它与原始对象具有相同的状态。要使用clone()方法，类必须实现Cloneable接口，并重写clone()方法。</li><li>finalize()：在对象被垃圾回收器回收之前调用，用于进行一些清理操作。在Java 9及之后的版本中，该方法已经被弃用，推荐使用try-with-resources或其他资源管理技术进行清理操作。</li><li>notify()、notifyAll()、wait()：这些方法用于实现线程间的协作。notify()方法唤醒一个正在等待该对象的线程，notifyAll()方法唤醒所有等待该对象的线程，wait()方法使当前线程等待直到其他线程通知或超时。</li></ol><div>这些是Object类的一些主要方法，其他还有一些辅助方法，比如getClassLoader()、finalize()等。需要注意的是，Object类中的一些方法可能需要在子类中进行重写，以实现更具体的行为。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "d7cf7692-b334-4faf-8239-98b4ea5a3e30"
                        },
                        "children": [
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">equals</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "ea425c1e-6c43-4f7d-8bd4-287d1aaa2710"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">自反性</span></p>",
                                            "richText": true,
                                            "expand": true,
                                            "isActive": false,
                                            "uid": "74fd8f0d-f272-42c8-8043-d5fed2d01b2f"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">对称性</span></p>",
                                            "richText": true,
                                            "expand": true,
                                            "isActive": false,
                                            "uid": "8850eaba-85f0-44f4-bf00-3291efeaf3cb"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">传递性</span></p>",
                                            "richText": true,
                                            "expand": true,
                                            "isActive": false,
                                            "uid": "643f1c4e-15ec-4e38-9295-8358882bdd19"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">一致性</span></p>",
                                            "richText": true,
                                            "expand": true,
                                            "isActive": false,
                                            "uid": "254968d5-6534-4db7-8c9e-1f7e8924321b"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">hashcode</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "c6753586-e9a3-4f48-b5ce-259293c6817e"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">toString</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "b4cf59ed-32bd-4665-9d93-9c57004d5fa9"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">getClass</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "39b3db85-a576-459d-807d-51d34ebede03"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">clone</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "73088df4-81b9-4a7c-b1cc-e69ab5d4dd6e"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">notify()、notifyAll()、wait()</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "82d38c26-5285-48d9-b761-6701710031a6"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">hashCode和equals的关系</span></p>",
                            "note": "<div>hashCode()和equals()方法在Java中是密切相关的，它们一起用于处理对象的相等性。</div><div>equals()方法用于比较两个对象是否相等。在默认情况下，equals()方法比较的是对象的引用是否相等，即是否指向同一个内存地址。但是，可以在类中重写equals()方法来定义自己的相等逻辑，比如比较对象的属性值是否相等。</div><div>hashCode()方法返回对象的哈希码值，它是一个int类型的整数。哈希码用于在散列数据结构中快速查找对象，比如在使用HashMap、HashSet等集合类时。哈希码的主要作用是将对象映射到散列桶中，从而加快查找的速度。</div><div>在Java中，equals()方法和hashCode()方法应该保持一致。也就是说，如果两个对象通过equals()方法判断为相等，那么它们的hashCode()方法应该返回相同的哈希码值。这是因为在散列数据结构中，当两个对象的哈希码相等时，会进一步调用equals()方法来比较它们的实际内容是否相等。</div><div>为了保持一致性，当重写equals()方法时，通常也需要重写hashCode()方法。在重写hashCode()方法时，应该使用与equals()方法中使用的相同属性来计算哈希码值。这样可以确保相等的对象具有相同的哈希码值，从而正确地在散列数据结构中进行查找和比较。</div><div>需要注意的是，在重写equals()方法和hashCode()方法时，需要遵循一些约定和规则，比如确保equals()方法满足自反性、对称性、传递性和一致性等，同时hashCode()方法应该满足等价对象具有相等的哈希码值。详细的规则和约定可以参考Java官方文档中对这两个方法的说明。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "35a3ad37-c642-4334-bf2b-06bded5785f4"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">==和equals有什么区别</span></p>",
                            "note": "<div>在Java中，\"==\"和equals()是用于比较对象的两种不同方式，它们有以下区别：</div><ol><li>\"==\"操作符：它用于比较两个对象的引用是否相等，即是否指向同一个内存地址。当使用\"==\"操作符比较两个对象时，它会检查对象的引用是否相同，而不考虑对象的实际内容。如果两个对象的引用相等，即指向同一个内存地址，那么\"==\"操作符返回true；否则返回false。</li><li>equals()方法：它用于比较两个对象的实际内容是否相等。默认情况下，equals()方法在Object类中比较的是对象的引用是否相等，与\"==\"操作符的行为相同。但是，可以在类中重写equals()方法来定义自己的相等逻辑，比如比较对象的属性值是否相等。如果两个对象的实际内容相等，即满足自定义的相等逻辑，那么equals()方法返回true；否则返回false。</li></ol><div>总结起来，\"==\"操作符比较的是两个对象的引用是否相等，而equals()方法比较的是两个对象的实际内容是否相等。在大多数情况下，应该使用equals()方法来比较对象的相等性，因为它可以根据对象的实际内容来确定相等性，而不仅仅是比较引用。但是要注意，使用equals()方法之前应该确保对象不为null，以避免空指针异常。</div><div>需要注意的是，对于基本数据类型（如int、double等），\"==\"操作符比较的是值是否相等，而不是引用。这是因为基本数据类型是直接存储在栈中的，没有引用的概念。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "f15da462-ba06-4b1d-9af5-2fac61bc7551"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "text": "<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">关键字</span></p>",
                    "richText": true,
                    "expand": true,
                    "isActive": false,
                    "uid": "8edc59ff-96b5-4408-9ae0-713fefa9a76c"
                },
                "children": [
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">static</span></p>",
                            "note": "<div>在Java中，`static` 是一个关键字，用于修饰成员变量、成员方法和代码块。它具有以下几个作用：<br><br>1. 静态变量（静态字段）：使用 `static` 关键字修饰的成员变量是静态变量，也称为类变量。静态变量属于类，而不是属于类的实例。它在类加载时被初始化，并且在整个程序运行期间只有一份拷贝。静态变量可以通过类名直接访问，无需创建类的实例。<br><br>2. 静态方法：使用 `static` 关键字修饰的成员方法是静态方法，也称为类方法。静态方法属于类，而不属于类的实例。静态方法可以通过类名直接调用，无需创建类的实例。静态方法只能访问静态成员（静态变量和静态方法），不能直接访问非静态成员。<br><br>3. 静态代码块：使用 `static` 关键字修饰的代码块是静态代码块，它在类加载时执行，并且只执行一次。静态代码块常用于初始化静态变量或执行其他一次性的静态操作。<br><br>4. 共享数据：静态成员（静态变量和静态方法）属于类，被所有类的实例所共享。可以通过静态变量在不同的实例之间共享数据，或者通过静态方法提供公共的行为或功能。<br><br>5. 方便访问：静态成员可以通过类名直接访问，无需创建类的实例。这使得在没有类的实例的情况下，也可以使用类的静态成员。<br><br>需要注意的是，静态成员存在一些限制和注意事项：<br>- 静态方法只能直接调用其他静态方法或访问静态变量，无法直接调用非静态方法或访问非静态变量。<br>- 静态成员在内存中存在一直到程序结束，可能导致一些资源的持有时间过长，需要注意资源的释放和管理。<br>- 静态成员的修改会影响所有使用该静态成员的地方，需要谨慎使用以避免意外的副作用。<br>- 静态成员属于类，可以通过类名进行访问，但这也使得代码的耦合性增加，应慎重考虑使用静态成员的场景。<br><br>总之，`static` 关键字允许我们在类级别上定义和使用成员，提供了一些特殊的功能和行为，但也需要注意合理使用以避免潜在的问题。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "51cada9e-c5cd-424b-b04c-9c9280ec586a"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">final</span></p>",
                            "note": "<div>在Java中，`final` 是一个修饰符，用于标识不可变的实体或具有特殊行为的元素。`final` 关键字可以应用于类、方法和变量，具有以下作用：<br><br>1. 不可继承的类：当用 `final` 修饰一个类时，表示该类是最终的，不能被其他类继承。这主要用于防止类的继承，保护类的完整性和安全性。<br><br>2. 不可重写的方法：当用 `final` 修饰一个方法时，表示该方法是最终的，不能被子类重写。这用于确保方法的行为不会被子类修改，保护方法的一致性和安全性。<br><br>3. 不可变的变量：当用 `final` 修饰一个变量时，表示该变量是一个常量，不能再被修改。一旦给 `final` 变量赋予了初始值，就不能再改变它的值。这用于定义不可变的常量，提高代码的可读性、可维护性和安全性。<br><br>4. 安全发布对象：在多线程环境下，将对象声明为 `final` 可以确保该对象在被其他线程访问之前已经被正确初始化。这是一种安全发布对象的方式，可以避免潜在的线程安全问题。<br><br>5. 编译器优化：`final` 关键字可以为编译器提供一些优化的机会，例如内联方法调用或常量折叠等。这可以提高程序的执行效率和性能。<br><br>需要注意以下几点：<br>- `final` 修饰的类不能被继承，但可以进行实例化。<br>- `final` 修饰的方法不能被子类重写，但可以被继承和调用。<br>- `final` 修饰的变量必须在声明时进行初始化，且不能再次赋值。<br>- `final` 修饰的引用变量指向的对象本身是可变的，但引用变量不能再指向其他对象。<br><br>总之，`final` 关键字用于表示不可变性、不可修改性和最终性，提供了一些特殊行为和语义，用于保护类、方法和变量的完整性、安全性和可靠性。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "fc5de881-7ff9-4ef2-808b-bf37a8a2409a"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">synchronized</span></p>",
                            "note": "<div>在Java中，`synchronized` 是一个关键字，用于实现线程之间的同步和互斥访问，确保多线程环境下的数据安全性。`synchronized` 的作用体现在以下几个方面：<br><br>1. 互斥访问：`synchronized` 用于修饰方法或代码块时，可以确保同一时间只有一个线程可以进入被修饰的方法或代码块。这样可以避免多个线程同时修改共享数据导致的数据不一致或冲突。<br><br>2. 对象锁：当 `synchronized` 修饰方法时，它实际上获取了方法所属对象的锁（也称为对象监视器）。只有获得了对象锁的线程才能执行被修饰的方法，其他线程将被阻塞等待锁的释放。<br><br>3. 类锁：当 `synchronized` 修饰静态方法时，它获取的是该方法所属的类的锁（也称为类监视器）。类锁是在类级别上实现的互斥，防止多个线程同时访问该静态方法。<br><br>4. 同步块：`synchronized` 还可以用于修饰代码块，通过指定一个对象作为锁，实现对该代码块的互斥访问。只有获得了指定对象的锁的线程才能执行代码块，其他线程将被阻塞等待锁的释放。<br><br>5. 内存可见性：`synchronized` 不仅提供了互斥访问的功能，还具有内存可见性的特性。当一个线程释放锁时，它会将对共享变量所做的修改刷新到主内存中，使得其他线程能够看到最新的值。<br><br>需要注意以下几点：<br>- `synchronized` 仅在多线程环境下才有意义，对于单线程程序没有实际作用，并且会引入额外的性能开销。<br>- `synchronized` 的使用必须保证锁对象的一致性，即在互斥访问的各个线程中使用相同的锁对象。<br>- `synchronized` 不能解决所有的并发问题，有些复杂的场景需要使用更高级的并发工具和技术，如 `Lock` 接口和 `java.util.concurrent` 包中的类。<br><br>总之，`synchronized` 关键字用于实现线程之间的同步和互斥访问，确保在多线程环境下的数据安全性和正确性。它提供了互斥访问、锁机制和内存可见性的功能，是常用的处理并发编程的工具之一。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "9853cd42-0c09-43e8-af93-d610ce92b0f6"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">volatile</span></p>",
                            "note": "<div>在Java中，`volatile` 是一个关键字，用于声明变量的特性，主要用于确保变量的可见性和禁止指令重排序。`volatile` 的作用体现在以下几个方面：<br><br>1. 可见性：当一个变量被声明为 `volatile` 时，对该变量的写操作将立即刷新到主内存中，而对该变量的读操作将从主内存中获取最新的值，而不是使用线程的本地缓存。这确保了当一个线程修改了 `volatile` 变量的值后，其他线程能够立即看到修改后的值，从而保证了多线程环境下的变量可见性。<br><br>2. 禁止指令重排序：`volatile` 关键字还可以禁止编译器和处理器对指令进行重排序，保证指令的顺序与程序代码的顺序一致。这对于某些特定的场景和算法来说是非常重要的，例如双重检查锁定（Double-Checked Locking）中的单例模式实现。<br><br>需要注意以下几点：<br>- `volatile` 仅保证了变量的可见性和禁止指令重排序，并不能保证变量具备原子性。如果需要保证操作的原子性，需要使用其他的同步机制，如 `synchronized` 关键字或 `java.util.concurrent` 包中的原子类。<br>- `volatile` 变量的读操作和写操作都是原子的，但是复合操作（如自增、自减等）并不是原子的，需要额外的同步措施来保证原子性。<br>- `volatile` 关键字适用于多个线程共享的变量，而不适用于线程之间的通信和协作，对于这些场景需要使用其他的并发工具和技术。<br><br>总之，`volatile` 关键字用于确保变量的可见性和禁止指令重排序。它在多线程环境下用于保证共享变量的可见性，使得一个线程对变量的修改对其他线程立即可见。同时，它也可以保证指令的顺序与程序代码的顺序一致，避免了重排序引起的问题。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "fa897913-3e73-4638-a926-e89076a9c6b4"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">assert</span></p>",
                            "note": "<div>在Java中，`assert` 是一个关键字，用于实现断言（Assertion）。断言是一种在程序中插入的检查机制，用于在运行时对程序的状态进行验证和调试。`assert` 的作用体现在以下几个方面：<br><br>1. 调试和测试：`assert` 语句可以用于编写和执行调试和测试代码。通过在关键位置插入断言语句，可以验证程序的假设和预期行为是否满足，并发现潜在的错误和问题。当断言条件为 false 时，断言将会抛出 `AssertionError` 异常。<br><br>2. 验证前置条件：`assert` 语句可以用于验证方法的前置条件（输入条件）。在方法的开头使用断言语句，可以检查方法的参数是否满足预期要求，如果不满足则抛出异常。这有助于确保方法的正确使用和调用。<br><br>3. 程序的不变性：`assert` 语句可以用于验证程序中的不变性条件是否得到满足。不变性条件是指在程序的执行过程中始终保持不变的条件。通过在关键位置插入断言语句，可以验证不变性条件是否被破坏，从而及早发现程序中的错误和异常情况。<br><br>需要注意以下几点：<br>- 默认情况下，Java 虚拟机对 `assert` 语句是禁用的，即不会执行断言检查。要启用断言检查，需要在运行 Java 程序时使用 `-ea` 或 `-enableassertions` 参数。<br>- 断言语句应该用于检查程序中的错误情况和不变性条件，而不应该用于正常的业务逻辑和错误处理。断言语句在发布版本中可能会被禁用或移除，因此不应该依赖于断言语句的执行。<br><br>总之，`assert` 关键字用于实现断言，用于在程序中进行验证和调试。通过插入断言语句，可以检查程序的状态、验证前置条件和程序的不变性，并及早发现错误和异常情况。使用断言可以提高程序的可靠性和调试效率，但在发布版本中应谨慎使用，并避免依赖于断言语句的执行。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "32d38805-1a5d-4de5-bcf6-6ab44039c185"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">this</span></p>",
                            "note": "<div>在面向对象编程中，`this` 是一个关键字，代表当前对象的引用。它的作用体现在以下几个方面：<br><br>1. 引用当前对象：`this` 关键字用于引用当前对象，在对象的内部方法中使用它可以指向当前正在执行该方法的对象实例。通过使用 `this`，可以访问和操作当前对象的属性和方法。<br><br>2. 区分同名变量：当一个对象的成员变量和方法参数具有相同的名称时，可以使用 `this` 关键字来明确指定是对象的成员变量还是方法参数。这样可以避免命名冲突和歧义。<br><br>3. 构造器的调用：在对象的构造器（构造方法）中，`this` 关键字可以用于调用同一个类的其他构造器。通过使用 `this`，可以避免在构造器中重复编写相似的代码，实现构造器的重用。<br><br>4. 返回当前对象：某些方法可以返回当前对象的引用，以支持链式调用的编程风格。通过在方法中使用 `return this`，可以返回当前对象的引用，使得可以连续调用该对象的其他方法。<br><br>需要注意以下几点：<br>- `this` 关键字只能在实例方法（非静态方法）中使用，因为它代表当前对象的引用。<br>- 在静态方法中不能使用 `this` 关键字，因为静态方法不依赖于具体的对象实例。<br>- 在匿名内部类中，`this` 关键字表示该匿名内部类的实例，而不是包含它的外部类的实例。如果需要引用外部类的实例，可以使用外部类的类名加 `this`，例如 `OuterClass.this`。<br><br>总之，`this` 关键字用于引用当前对象，可以用于访问和操作当前对象的属性和方法，区分同名变量，调用同一类的其他构造器，以及返回当前对象的引用。它在面向对象编程中起到了指代和引用当前对象的重要作用。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "d97c8532-1dff-41d6-acc5-c10713717a7a"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "text": "<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">String类</span></p>",
                    "richText": true,
                    "expand": true,
                    "isActive": false,
                    "uid": "39190dc2-6755-4135-b1b9-9dfec6bc1bff"
                },
                "children": [
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">主要方法</span></p>",
                            "note": "<div>String类是Java中非常常用的类之一，它提供了许多用于处理字符串的方法。以下是String类的一些常用方法：</div><ol><li>length()：返回字符串的长度（字符个数）。</li><li>charAt(int index)：返回指定索引位置的字符。</li><li>substring(int beginIndex)：返回从指定索引开始到字符串末尾的子字符串。</li><li>substring(int beginIndex, int endIndex)：返回从指定索引开始到指定索引结束的子字符串。</li><li>concat(String str)：将指定字符串连接到原字符串的末尾。</li><li>contains(CharSequence sequence)：判断字符串是否包含指定的字符序列。</li><li>equals(Object obj)：判断字符串是否与指定对象相等。</li><li>isEmpty()：判断字符串是否为空（长度为0）。</li><li>indexOf(String str)：返回指定字符串在原字符串中第一次出现的索引位置。</li><li>lastIndexOf(String str)：返回指定字符串在原字符串中最后一次出现的索引位置。</li><li>replace(char oldChar, char newChar)：将字符串中所有出现的指定字符替换为新的字符。</li><li>split(String regex)：将字符串根据指定的正则表达式分割为字符串数组。</li><li>toLowerCase()：将字符串转换为小写形式。</li><li>toUpperCase()：将字符串转换为大写形式。</li><li>trim()：去除字符串两端的空白字符。</li><li>startsWith(String prefix)：判断字符串是否以指定前缀开头。</li><li>endsWith(String suffix)：判断字符串是否以指定后缀结尾。</li><li>format(String format, Object... args)：使用指定的格式化字符串和参数创建一个新的字符串。</li><li>compareTo(String anotherString)：按字典顺序比较两个字符串。</li></ol><div>这只是String类提供的部分方法，还有其他方法可以用于字符串的拼接、替换、格式化等操作。你可以根据需要选择合适的方法来操作和处理字符串。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "623214ee-83fd-48e5-8052-7b1a4ec41f65"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">支持正则表达式的方法</span></p>",
                            "note": "<ol><li>matches(String regex)：判断字符串是否与指定的正则表达式匹配</li><li>split(String regex)：根据指定的正则表达式将字符串分割为字符串数组。</li><li>replaceAll(String regex, String replacement)：使用指定的正则表达式替换字符串中所有匹配的部分。</li><li>replaceFirst(String regex, String replacement)：使用指定的正则表达式替换字符串中第一个匹配的部分。</li></ol>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "b91f7dd7-0a66-4548-8c7d-8a081c9ce53c"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">new 和\"\"的区别</span></p>",
                            "note": "<div>在Java中，String new和\"\"（空字符串）之间有几个重要的区别。</div><ol><li>创建方式：String new使用new关键字显式地创建一个新的String对象实例，而\"\"是使用字符串字面值表示法直接创建一个String对象。</li><li>内存分配：使用String new创建的字符串对象将在堆内存中分配空间，而\"\"创建的字符串对象将在字符串常量池中分配空间。字符串常量池是Java中一种特殊的内存区域，用于存储字符串字面值常量，以便实现字符串的重用。</li><li>字符串比较：String new创建的字符串对象是独立的，即使两个new创建的字符串内容相同，它们也不会被视为相等。而\"\"创建的字符串对象在字符串常量池中是唯一的，如果两个空字符串常量对象的内容相同，它们将被视为相等。</li></ol><div>示例代码：</div><div>java</div><pre>String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\nSystem.out.println(s1 == s2);  // 输出 false，因为两个对象是独立的\n\nString s3 = \"Hello\";\nString s4 = \"Hello\";\nSystem.out.println(s3 == s4);  // 输出 true，因为两个对象在字符串常量池中是相同的\n<br></pre><div>需要注意的是，虽然\"\"创建的字符串对象在字符串常量池中是唯一的，但是使用new关键字创建的字符串对象会每次都创建一个新的对象。因此，在比较字符串内容时，应该使用equals()方法而不是==操作符，以确保比较的是字符串的内容而不是引用。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "d0c26380-4f09-46ae-a5b4-fc235c919863"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">字符串相加的实现机制</span></p>",
                            "note": "<div>在Java中，字符串相加可以通过两种机制实现：使用+运算符和使用StringBuilder或StringBuffer类。</div><ol><li>使用+运算符：当使用+运算符连接两个字符串时，Java会自动创建一个新的字符串对象，将两个字符串的内容拼接起来。这是因为字符串在Java中是不可变的，即一旦创建，其内容就不能更改。因此，每次使用+运算符连接字符串时，实际上都会创建一个新的字符串对象。</li></ol><div>示例代码：</div><div>java</div><pre>String str1 = \"Hello\";\nString str2 = \" World!\";\nString result = str1 + str2;\nSystem.out.println(result);  // 输出 \"Hello World!\"\n<br></pre><div>上述代码中，使用+运算符将str1和str2连接成一个新的字符串对象result。</div><ol><li>使用StringBuilder或StringBuffer类：为了避免每次连接字符串都创建新的字符串对象，可以使用StringBuilder（在单线程环境下使用）或StringBuffer（在多线程环境下使用）类。这两个类提供了可变的字符串，可以进行高效的字符串拼接操作。</li></ol><div>示例代码：</div><div>java</div><pre>StringBuilder sb = new StringBuilder();\nsb.append(\"Hello\");\nsb.append(\" World!\");\nString result = sb.toString();\nSystem.out.println(result);  // 输出 \"Hello World!\"\n<br></pre><div>上述代码中，通过StringBuilder类的append()方法将字符串逐步添加到可变的字符串构建器中，最后使用toString()方法将可变的字符串转换为不可变的字符串对象。</div><div>使用StringBuilder或StringBuffer类的好处是，它们在内部维护一个可变的字符数组，避免了频繁创建新的字符串对象，从而提高了性能。特别是在需要大量字符串连接的情况下，使用可变的字符串类比使用+运算符更高效。</div><div>需要注意的是，StringBuilder和StringBuffer的API接口是相似的，但StringBuilder是非线程安全的，而StringBuffer是线程安全的。因此，如果在多线程环境下进行字符串拼接操作，应该使用StringBuffer类。在单线程环境下，推荐使用StringBuilder类以获得更好的性能。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "5903375d-4121-4d2b-9ac2-8d3d2fadaa00"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">String、StringBuilder、StringBuffer区别</span></p>",
                            "note": "<div>String、StringBuilder和StringBuffer是Java中用于处理字符串的类，它们之间有几个重要的区别：</div><ol><li>可变性：String类是不可变的，也就是说，一旦创建了String对象，其内容就不可更改。而StringBuilder和StringBuffer类是可变的，可以进行字符串的修改、拼接等操作。</li><li>线程安全性：String类是线程安全的，因为它的内容不可更改。而StringBuilder是非线程安全的，而StringBuffer是线程安全的。在多线程环境下，如果需要进行频繁的字符串操作，应该使用StringBuffer类，以确保线程安全。在单线程环境下，使用StringBuilder类可以获得更好的性能。</li><li>性能：由于String类的不可变性，每次对字符串进行修改、拼接等操作时，都会创建一个新的字符串对象，这可能导致性能的损耗。而StringBuilder和StringBuffer类是可变的，可以在原有对象的基础上进行修改，避免了频繁创建新的对象，因此在大量字符串操作时，使用StringBuilder或StringBuffer可以获得较好的性能。</li><li>API接口：String类具有丰富的API方法，用于字符串的截取、替换、分割等操作。StringBuilder和StringBuffer类也提供了类似的API方法，用于字符串的修改、拼接等操作。但是，StringBuilder和StringBuffer的API接口是相似的，但StringBuilder的方法不是线程安全的，而StringBuffer的方法是线程安全的。</li></ol><div>综上所述，如果在单线程环境下需要频繁进行字符串操作，推荐使用StringBuilder类以获得更好的性能。如果在多线程环境下进行字符串操作，应该使用StringBuffer类以确保线程安全。而String类则适用于不需要频繁修改字符串内容的场景，或者需要保证字符串内容不被修改的情况下使用。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "a97e6275-ed9e-4c81-a3c8-c5fe70912ec7"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">java8编译器对String求值表达式的优化</span></p>",
                            "note": "<div>Java 8 编译器对字符串求值表达式进行了一项重要的优化，即字符串连接操作的优化。在 Java 8 之前的版本中，使用 + 运算符连接多个字符串时，会生成大量的中间临时对象，导致性能下降。为了解决这个问题，Java 8 引入了基于 StringBuilder 的编译器优化，称为 \"String Concatenation\"（字符串拼接）优化。</div><div>在 Java 8 中，如果一个字符串求值表达式（如 \"Hello\" + name + \"!\"）中包含了多个字符串相加，编译器会自动将其优化为使用 StringBuilder 进行拼接的方式。这样可以避免创建大量的中间临时对象，提高了字符串连接操作的性能。</div><div>示例代码：</div><div>java</div><pre>String name = \"Alice\";\nString message = \"Hello\" + name + \"!\";\n<br></pre><div>在上述代码中，编译器会将字符串求值表达式 \"Hello\" + name + \"!\" 转化为以下形式：</div><div>java</div><pre>StringBuilder sb = new StringBuilder();\nsb.append(\"Hello\");\nsb.append(name);\nsb.append(\"!\");\nString message = sb.toString();\n<br></pre><div>通过使用 StringBuilder 进行字符串拼接，可以有效地减少中间临时对象的创建，提高了性能。</div><div>需要注意的是，字符串拼接优化只适用于编译期已知的字符串表达式，即字符串的值在编译时是已知的。如果字符串的值是在运行时才确定的，例如使用变量进行字符串拼接，优化就不会发生，仍然会创建中间临时对象，比如循环中的字符串拼接就不可被优化，仍然需要使用StringBuilder。</div><div>总结来说，Java 8 编译器对字符串求值表达式进行了优化，使用 StringBuilder 来避免创建大量的中间临时对象，从而提高了字符串连接操作的性能。这项优化在日常的字符串拼接中可以带来明显的性能提升。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "9e76ffa5-3902-428d-9874-69f54a4789f2"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "text": "<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">异常处理机制</span></p>",
                    "richText": true,
                    "expand": true,
                    "isActive": false,
                    "uid": "6006376f-4950-4732-9cd6-ff5f254377f6"
                },
                "children": [
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">继承体系</span></p>",
                            "note": "<div>在Java中，异常类的继承体系主要围绕Throwable类展开，它是所有异常类的基类。Java中的异常分为两种类型：可检查异常（Checked Exception）和不可检查异常（Unchecked Exception）。</div><ol><li>可检查异常（Checked Exception）：<ul><li>Exception：Exception是所有可检查异常的父类，它表示程序中可能出现的一般性异常情况。Exception类的直接子类包括：<ul><li>IOException：处理输入/输出操作中的异常情况。</li><li>SQLException：处理与数据库相关的异常情况。</li><li>其他自定义的可检查异常类。</li></ul></li></ul></li><li>不可检查异常（Unchecked Exception）：<ul><li>RuntimeException：RuntimeException是所有不可检查异常的父类，它表示程序中的错误操作、逻辑错误或其他非正常情况。RuntimeException类的直接子类包括：<ul><li>NullPointerException：当引用为空时，执行了对对象的方法或字段访问。</li><li>ArrayIndexOutOfBoundsException：当使用非法索引访问数组时。</li><li>ArithmeticException：当发生算术错误，例如除以零时。</li><li>IllegalArgumentException：当传递给方法的参数不合法时。</li><li>ClassCastException：当试图将对象强制转换为不兼容的类型时。</li><li>其他自定义的不可检查异常类。</li></ul></li></ul></li></ol><div>此外，还有一个特殊的异常类：</div><ul><li>Error：Error类是所有严重错误的父类，表示系统级别的错误和问题，通常由虚拟机抛出，无需程序显式捕获。Error类的直接子类包括：<ul><li>OutOfMemoryError：内存不足错误。</li><li>StackOverflowError：堆栈溢出错误。</li><li>其他系统级别的错误类</li></ul></li></ul>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "c975124e-eac5-46fe-9183-371b0deac89c"
                        },
                        "children": [
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">可检查异常</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "8f7749cb-06fd-469c-ad3f-3f1ee20c64e0"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">不可检查异常</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "8d4d94fe-120c-4162-9db9-77d83ca4baa5"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">error</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "81869817-c856-4da7-bb48-677209f7357d"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">处理机制</span></p>",
                            "note": "<div>Java的异常处理机制通过try-catch语句块来实现。异常处理的主要目的是在程序出现异常时，提供一种机制来捕获、处理和恢复异常，以避免程序崩溃或产生不可预测的结果。</div><div>以下是Java异常处理机制的基本要点：</div><ol><li>抛出异常（Throwing Exceptions）：<ul><li>当在代码块中发生异常情况时，可以使用throw语句显式地抛出异常。异常类型可以是Java内置的异常类，也可以是自定义的异常类。</li></ul></li><li>捕获异常（Catching Exceptions）：<ul><li>使用try-catch语句块来捕获可能抛出的异常。try块中包含可能会引发异常的代码，而catch块用于捕获和处理特定类型的异常。</li><li>可以使用多个catch块来捕获不同类型的异常，从而实现针对不同异常类型的特定处理逻辑。</li></ul></li><li>处理异常（Handling Exceptions）：<ul><li>在catch块中，可以编写处理异常的代码逻辑，例如记录日志、显示错误信息、进行恢复操作等。</li><li>可以选择在catch块中重新抛出异常，以便在更高层次的代码中继续处理或传播异常。</li></ul></li><li>finally块：<ul><li>可以使用finally块来包含一些无论是否发生异常都需要执行的代码。finally块中的代码在try-catch块执行完毕后总是会被执行。</li></ul></li><li>异常链：<ul><li>在捕获异常并重新抛出时，可以使用catch块中的throw语句将原始异常包装成一个新的异常，并保留原始异常的信息。这样就形成了异常链，可以追溯异常的发生和传播路径。</li></ul></li><li>自定义异常：<ul><li>可以通过继承现有的异常类（如Exception或RuntimeException的子类）或实现Throwable接口来创建自定义的异常类，以满足特定的应用需求。</li></ul></li></ol>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "6798b828-1e09-42da-abf3-c83f27ec14bc"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">finally中return</span></p>",
                            "note": "<div>在finally块中包含return语句时，会有一些特殊的行为。下面是对这种情况的解释：</div><ol><li>finally块中的return语句执行时机：<ul><li>当finally块中包含return语句时，无论在try块或catch块中是否执行了return语句，finally块中的return语句将在try-catch-finally结构结束前执行。</li><li>如果finally块中有return语句，它将覆盖在try块或catch块中的任何return语句。</li></ul></li><li>返回值的选择：<ul><li>如果在finally块中执行了return语句，并且在之前的try块或catch块中也执行了return语句，则最终的返回值是来自finally块中的return语句。</li><li>如果finally块中没有return语句，或者finally块中的return语句没有被执行到，则最终的返回值将来自之前的try块或catch块中的return语句。</li></ul></li><li>返回值的异常：<br><br><ul><li>如果在finally块中的return语句导致异常被抛出（例如，return语句在抛出异常之后执行），异常将被覆盖，最终的异常将是finally块中抛出的异常。</li></ul></li></ol><div><br></div><div>需要注意的是，finally块中的return语句可能会导致一些潜在的问题和行为不一致的情况。因此，在使用finally块时，应谨慎使用return语句，并确保逻辑的正确性和一致性。如果可能，建议避免在finally块中包含return语句，或者在使用时仔细考虑相关的控制流程</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "b273b9e8-8fe9-4d7b-b401-c6760eb21f8b"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">try-with-resources</span></p>",
                            "note": "<ol><li>简化资源关闭：<ul><li>在使用传统的try-catch-finally结构时，需要显式地在finally块中关闭资源。而使用try-with-resources语句后，可以直接在try块中声明和初始化资源，并在代码块结束后自动关闭资源，无需显式编写关闭代码。</li></ul></li><li>确保资源的正确关闭：<ul><li>try-with-resources语句确保资源在使用完毕后被正确关闭，即使在代码块中发生异常或错误。它会自动调用资源的close()方法来释放资源，无需手动处理关闭操作，减少了出错的可能性。</li></ul></li><li>处理多个资源：<ul><li>try-with-resources语句支持同时管理多个资源，通过在try块的括号中使用分号分隔多个资源的声明和初始化。这样可以确保所有资源在退出代码块时都会被正确关闭，无论是正常执行还是发生异常。</li></ul></li></ol><div>资源的关闭顺序与声明的顺序相反。也就是说，先声明的资源会后关闭，后声明的资源会先关闭。这个顺序确保了嵌套资源按照正确的顺序进行关闭，从而避免潜在的依赖关系和资源泄漏。</div><div>下面是一个示例，展示了try-with-resources语句中资源关闭的顺序：</div><div>java</div><div><br></div><pre>try (ResourceType1 resource1 = new ResourceType1();\n     ResourceType2 resource2 = new ResourceType2();\n     // ... 更多资源声明\n) {\n    // 使用资源的代码\n} catch (ExceptionType exception) {\n    // 异常处理代码\n}\n<br></pre><div>在这个示例中，如果存在多个资源，那么资源的关闭顺序将与声明的顺序相反。即先关闭ResourceType2，再关闭ResourceType1。这确保了在关闭资源时，依赖于其他资源的资源会先被关闭，以确保正确的清理和释放。</div><div>需要注意的是，资源的关闭顺序是在try-with-resources语句的控制下进行的，而不受代码块中的逻辑顺序影响。无论代码块中的逻辑如何，资源的关闭顺序都是按照声明的相反顺序进行的。<br><br>这些资源必须实现AutoCloseable接口或其子接口，以便能够在try-with-resources语句中进行自动关闭。</div><div>一些常见的可以在try-with-resources语句中自动关闭的资源包括：</div><ol><li>InputStream和OutputStream：<ul><li>例如，FileInputStream、FileOutputStream、ByteArrayInputStream、ByteArrayOutputStream等。</li></ul></li><li>Reader和Writer：<ul><li>例如，FileReader、FileWriter、BufferedReader、BufferedWriter等。</li></ul></li><li>Socket和ServerSocket：<ul><li>用于网络通信的套接字资源，例如，Socket、ServerSocket、DatagramSocket等。</li></ul></li><li>JDBC资源：<ul><li>数据库相关的资源，例如，Connection、Statement、ResultSet等。</li></ul></li><li>图形相关资源：<ul><li>例如，ImageInputStream、ImageOutputStream、Font等。</li></ul></li><li>ZIP和压缩文件资源：<ul><li>例如，ZipFile、ZipInputStream、ZipOutputStream等。</li></ul></li><li>缓冲区资源：<ul><li>例如，BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream等。</li></ul></li></ol><div>除了上述示例外，几乎所有实现了AutoCloseable接口的资源都可以在try-with-resources语句中自动关闭。如果你有自定义的资源类，只需确保该类实现了AutoCloseable接口并正确实现了close()方法，就可以在try-with-resources语句中使用它。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "39b1a0c4-b78e-4411-bf6a-03a7a782c18d"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "text": "<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">HashMap</span></p>",
                    "richText": true,
                    "expand": true,
                    "isActive": false,
                    "uid": "9f681356-6767-4b20-87f9-3aea4ca4f1bc"
                },
                "children": [
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">特点</span></p>",
                            "note": "<div>HashMap是Java中常用的集合类之一，它具有以下特点：</div><ol><li>键值对存储：HashMap以键值对（Key-Value）的形式存储数据。每个键对应一个值，通过键可以快速定位到对应的值。这种键值对的存储方式使得HashMap适用于需要根据键来查找值的场景。</li><li>集合无序：HashMap中的键值对是无序存储的，即插入元素的顺序不一定与遍历顺序相同。如果需要有序存储，可以考虑使用LinkedHashMap。</li><li>基于哈希表：HashMap内部使用哈希表（Hash Table）实现数据的存储和查找。通过将键转换为哈希码（Hash Code），可以快速计算出键值对在哈希表中的存储位置，从而实现高效的数据访问。</li><li>允许空键和空值：HashMap允许使用null作为键和值的存储，即可以将null作为键或值插入到HashMap中。</li><li>不同步：HashMap是非线程安全的，不具备并发访问的能力。如果在多线程环境下使用HashMap，需要进行额外的同步操作或者考虑使用线程安全的Map实现，如ConcurrentHashMap。</li><li>高效的查找和插入操作：基于哈希表的实现使得HashMap在查找和插入操作上具有高效的性能。平均情况下，这两种操作的时间复杂度为O(1)，即常数时间复杂度。然而，在极端情况下，哈希碰撞（Hash Collision）可能导致查找和插入的性能下降，使得时间复杂度接近O(n)。</li></ol><div>需要注意的是，由于哈希表的特性，HashMap在存储大量数据时可能会占用较多的内存空间，因为需要预留一定的空间用于存储哈希冲突的元素。另外，当哈希函数的设计不好或者键的分布不均匀时，哈希碰撞的概率会增加，影响HashMap的性能。因此，在使用HashMap时，应尽量选择合适的哈希函数和避免哈希冲突。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "0d56ba5e-ebed-4edb-875f-acd7a6f25e8d"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">底层实现原理</span></p>",
                            "note": "<div>HashMap是Java中常用的散列映射表的实现，它基于哈希表（Hash table）的数据结构。下面是HashMap的基本底层实现原理：</div><ol><li>哈希桶数组（Hash Bucket Array）：<ul><li>HashMap内部维护了一个存储元素的数组，称为哈希桶数组。它是一个固定大小的数组，每个元素称为桶（bucket）。</li><li>桶用于存储键值对的数据，每个桶可以包含一个或多个键值对。不同的键值对可能被哈希到相同的桶中，因此桶内部可能形成一个链表或红黑树的数据结构。</li></ul></li><li>哈希函数（Hash Function）：<ul><li>HashMap使用哈希函数将键映射到桶的索引位置。哈希函数可以将键的信息转换为桶数组中的索引值。</li><li>在理想情况下，哈希函数能够将键均匀地分布到桶数组中，以减少冲突和碰撞。</li></ul></li><li>冲突解决：<ul><li>由于哈希函数的有限性，不同的键可能会被映射到相同的桶中，这称为冲突。HashMap使用链表或红黑树来解决冲突。</li><li>当多个键被映射到同一个桶时，它们会以链表的形式存储在桶中。当链表长度超过一定阈值时，链表会转换为红黑树，以提高查找效率。</li></ul></li><li>键值对存储：<ul><li>HashMap使用键值对（Key-Value）的方式存储数据。每个键值对通过哈希函数计算出对应的桶索引，并存储在相应的桶中。</li><li>在存储键值对时，首先根据键的哈希值找到对应的桶，然后在桶内进行查找或插入操作，以维护链表或红黑树的结构。</li></ul></li><li>扩容与重新哈希：<ul><li>当HashMap中的元素数量超过阈值（负载因子）时，HashMap会自动进行扩容操作，即重新调整桶数组的大小。</li><li>扩容时，HashMap会创建一个新的更大的桶数组，并将所有的键值对重新哈希到新的桶中。这涉及到对每个键值对重新计算哈希值和重新分配桶的过程。</li><li>扩容操作会导致一定的性能开销，但能够保持桶数组的平均填充因子在可接受的范围内，以提高查找和插入的效率。</li></ul></li></ol><div>HashMap的底层实现充分利用了哈希表的特性，以提供高效的键值对存储和查找。然而，在使用HashMap时需要注意选择合适的负载因子和初始容量，以平衡空间和时间的开销。此外，对于敏感性能场景，还可以考虑使用ConcurrentHashMap等线程安全的替代实现。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "377baa3c-4793-4ec1-b58b-ecfc04284087"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">JDK7和JDK8的hashmap区别</span></p>",
                            "note": "<div>HashMap在 JDK 7 和 JDK 8 中有一些重要的区别，主要包括以下几点：</div><ol><li>数据结构：JDK 7 中的 HashMap 使用数组和链表的组合实现冲突解决，而 JDK 8 引入了红黑树来优化链表过长的情况，提高查询性能。</li><li>存储方式：JDK 7 中的 HashMap 在链表长度达到一定阈值（默认为8）时会将链表转换为红黑树，但在链表长度小于等于阈值时，仍然使用链表存储。而 JDK 8 中的 HashMap 在链表长度达到一定阈值（默认为8）时，会优先考虑将链表转换为红黑树，但在链表长度小于阈值时，会使用自平衡的红黑树替代链表。</li><li>扩容策略：JDK 7 和 JDK 8 在扩容时的处理方式不同。JDK 7 中的 HashMap 在扩容时会将原数组中的元素重新计算哈希值并重新放置到新的扩容数组中，这可能导致大量的键值对重新分布，性能较低。JDK 8 引入了树化过程（Treeify）和退化过程（Untreeify）来改进扩容过程。在扩容时，JDK 8 的 HashMap 会首先判断桶中的链表长度是否达到阈值，如果达到则将链表转换为红黑树，否则直接复制元素到新的扩容数组中。</li></ol>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "5b2b7f5b-be6d-42ee-8fe5-c139da6e64b8"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">负载因子和初始容量</span></p>",
                            "note": "<div>在使用HashMap时，负载因子（load factor）和初始容量（initial capacity）是需要考虑和选择的两个重要参数。它们会影响到HashMap的性能和内存占用。下面是对负载因子和初始容量的选择的一些建议：</div><ol><li>负载因子（Load Factor）：<ul><li>负载因子表示哈希表在自动扩容之前可以达到的平均填充程度。它的取值范围是大于0的浮点数。</li><li>通常情况下，负载因子的默认值为0.75，这是一个经验性的选择，在时间和空间开销之间取得了一定的平衡。</li><li>如果对内存占用要求较高，可以选择较小的负载因子，如0.5或更小。这将导致更频繁的扩容操作，但会减少每个桶的平均链表长度，提高查找性能。</li><li>如果对插入和查找性能要求较高，可以选择较大的负载因子，如0.9或更大。这将减少扩容的频率，但会增加每个桶的平均链表长度，可能降低查找性能。</li></ul></li><li>初始容量（Initial Capacity）：<ul><li>初始容量表示哈希表中初始桶的数量。它需要根据预期存储的键值对数量进行合理的选择。</li><li>如果能够估计要存储的键值对数量，可以根据预估值设置初始容量，以避免过多的扩容操作。可以使用构造函数HashMap(int initialCapacity)或HashMap(int initialCapacity, float loadFactor)来指定初始容量。</li><li>如果无法准确估计键值对数量，可以选择使用默认的初始容量（16），HashMap会根据负载因子的值进行自动扩容。</li><li>注意，设置过小的初始容量可能导致频繁的扩容操作，而设置过大的初始容量可能浪费内存空间。因此，根据实际情况选择一个合适的初始容量是重要的。</li></ul></li></ol>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "9645b307-fe9b-4136-9908-8e0b768eb0d9"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">循环链表</span></p>",
                            "note": "<div>在 HashMap 中，循环链表是由哈希冲突（Hash Collision）引起的。当不同的键映射到相同的哈希桶（bucket）时，就会发生哈希冲突。为了解决冲突，HashMap 使用链表或红黑树来存储具有相同哈希值的键值对。</div><div>当发生哈希冲突时，新的键值对将被插入到哈希桶的链表或树的末尾。如果同一个哈希桶中已经存在其他键值对，那么新的键值对将会以链表节点的形式添加到链表的末尾。</div><div>在这种情况下，哈希桶中形成的链表会成为一个循环链表。这是因为每个链表节点都有一个指针指向下一个节点，而最后一个节点的指针会指向链表的头节点，形成循环。</div><div>下面是一个示例，演示了哈希冲突导致循环链表的产生：</div><div>plaintext</div><pre>哈希桶1:\n+---+       +---+       +---+       +---+\n| k1 | ---&gt; | k2 | ---&gt; | k3 | ---&gt; | k1 |\n| v1 |       | v2 |       | v3 |       | v1 |\n+---+       +---+       +---+       +---+\n<br></pre><div>在上述示例中，键 k1、k2 和 k3 都映射到了同一个哈希桶，它们形成了一个循环链表。节点 k3 的指针指向节点 k1，从而形成了循环。</div><div>需要注意的是，循环链表只会在哈希冲突发生时才会形成，并且只存在于具有相同哈希值的键值对之间。在 HashMap 的实现中，当链表长度超过一定阈值（默认为8）时，链表会被转换为红黑树，从而提高查询性能。因此，循环链表的存在时间可能是有限的，取决于哈希表中键值对的插入和删除操作。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "ec7e052a-1e59-4457-aff7-e443414af03d"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">哈希冲突</span></p>",
                            "note": "<div>HashMap 使用了两种主要的方法来解决哈希冲突：开放寻址法（Open Addressing）和链表法（Separate Chaining）。</div><ol><li>开放寻址法：<br>在开放寻址法中，当发生哈希冲突时，会继续探测哈希表的下一个位置，直到找到一个空闲的位置来存储冲突的键值对。常用的探测方法包括线性探测、二次探测和双重哈希等。这种方法需要保证哈希表的容量大于等于键值对的数量，并且需要处理删除操作时的标记占用等情况。开放寻址法的优点是节省了额外存储链表或树的空间，但可能会导致聚集性冲突（Clustering），影响性能。</li><li>链表法：<br>在链表法中，每个哈希桶都可以存储一个链表或红黑树。当发生哈希冲突时，新的键值对会被追加到哈希桶的链表或树的末尾。这样，具有相同哈希值的键值对都会存储在同一个哈希桶中，形成一个链表或树结构。链表法可以处理大量的哈希冲突，且在插入和删除操作上具有良好的性能，但需要额外的存储空间来存储链表或树结构。</li></ol><div>在 JDK 8 及之前的版本中，HashMap 使用了链表法来解决哈希冲突。具体地，每个哈希桶存储的是一个链表，当链表长度超过一定阈值（默认为8）时，链表会被转换为红黑树，以提高查询性能。这样可以在大多数情况下保持较低的查询复杂度，但在极端情况下，仍可能出现链表过长的问题，影响性能。</div><div>从 JDK 8 开始，HashMap 进一步优化了哈希冲突的处理方式。当链表长度超过一定阈值时，不再直接转换为红黑树，而是先判断桶的数量是否超过一定阈值（默认为64），如果超过则进行扩容操作，将哈希表的容量翻倍，从而减少链表长度，提高性能。这种优化方法在一定程度上解决了链表过长的问题。</div><div>需要注意的是，从 JDK 7 开始，HashMap 引入了哈希桶中链表转换为红黑树的优化，以提高具有大量冲突的桶的查询性能。这种优化在解决极端情况下链表过长的问题时很有效。</div><div>综上所述，HashMap 使用开放寻址法或链表法来解决哈希冲突。在 JDK 8 及之前的版本中，主要采用链表法，并引入红黑树来优化链表过长的情况。而从 JDK 8 开始，进一步优化了链表转换为红黑树的策略，并在必要时进行扩容操作，以提高性能。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "4f38ce2f-cae8-4168-b0f8-a7020887398b"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "text": "<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">ConcurrentHashMap</span></p>",
                    "richText": true,
                    "expand": true,
                    "isActive": false,
                    "uid": "b6ab8635-f667-4c31-a1aa-f3bd6638a043"
                },
                "children": [
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">与hashmap区别</span></p>",
                            "note": "<div>oncurrentHashMap 和 HashMap 是 Java 中两种不同的哈希表实现，它们在多线程环境下的行为和性能有所不同。</div><ol><li>线程安全性：<ul><li>HashMap 是非线程安全的，不适合在多线程环境下并发操作。如果多个线程同时修改一个 HashMap 实例，可能导致数据不一致或抛出异常。</li><li>ConcurrentHashMap 是线程安全的，支持多线程并发操作。它使用了分段锁（Segment Locking）和更细粒度的锁机制，允许多个线程同时读取和写入不同的分段，从而提供更高的并发性能和线程安全性。</li></ul></li><li>并发性能：<ul><li>HashMap 在多线程环境下性能较差，需要使用外部同步手段（如显式的锁）来保证线程安全。在高并发情况下，可能会发生竞争和阻塞，导致性能下降。</li><li>ConcurrentHashMap 在高并发环境下具有更好的性能。它通过将数据分割为多个段（Segments），每个段都有自己的锁，不同的线程可以同时操作不同的段，从而提供更高的并发性能。</li></ul></li><li>迭代器（Iterator）一致性：<ul><li>在 HashMap 中，如果在迭代过程中对 HashMap 进行修改（如插入、删除操作），可能会导致 ConcurrentModificationException 异常或数据不一致。</li><li>ConcurrentHashMap 提供了弱一致性的迭代器。它允许在迭代过程中进行修改操作，但不能保证迭代器能够反映出所有修改的结果。</li></ul></li><li>null 键和 null 值：<ul><li>HashMap 允许使用 null 作为键和值。</li><li>ConcurrentHashMap 不允许使用 null 作为键和值。如果尝试存储 null 键或值，将抛出 NullPointerException。</li></ul></li></ol><div>总结来说，ConcurrentHashMap 是线程安全的哈希表实现，适用于多线程并发环境。它提供了较好的并发性能和线程安全性，通过分段锁和细粒度的锁机制来实现。相比之下，HashMap 是非线程安全的，不适合在多线程环境下使用，并发操作需要额外的同步手段</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "73f17d8e-809a-48dd-92d5-5b8483b1eb9a"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">实现方式</span></p>",
                            "note": "<div>ConcurrentHashMap 在 JDK 中的实现方式是基于分段锁（Segment Locking）和数组的结构。</div><ol><li>分段锁：<br>``ConcurrentHashMap 将整个数据结构分割为多个段（Segments），每个段都有一个独立的锁。不同的线程可以同时访问和修改不同的段，从而提供了更高的并发性能。每个段可以看作是一个独立的哈希表，包含一部分键值对。默认情况下，ConcurrentHashMap` 的段数是 16，可以通过构造函数的参数进行调整。</li><li>数组和链表：<br>每个段内部使用数组和链表的结构来存储键值对。每个段都有一个 HashEntry 数组，数组的每个元素是一个链表的头节点。每个链表节点包含键、值和指向下一个节点的指针。当发生哈希冲突时，新的键值对会插入到对应段的链表中，形成一个链表结构。</li><li>定位元素：<br>在 ConcurrentHashMap 中，元素的定位是通过两次哈希操作实现的。首先，对键进行哈希操作得到一个哈希值，然后使用该哈希值的高位来定位到对应的段，再使用低位哈希值来定位到对应段内的链表节点。</li><li>锁策略：<br>``ConcurrentHashMap` 中的锁是基于段的，每个段都有一个独立的锁。当进行读取操作时，不需要加锁，可以并发地进行。而在进行写入、更新或删除操作时，需要先获取对应段的锁，这样可以保证同一段的操作是互斥的，但不同段之间的操作可以并发进行，提高了并发性能。</li></ol><div>ConcurrentHashMap 的实现方式充分利用了分段锁和数组链表结构的优势，允许多个线程同时访问和修改不同的段，从而提供了更高的并发性能。通过细粒度的锁机制，避免了对整个数据结构的全局加锁，提高了并发访问的效率。此外，ConcurrentHashMap 还提供了一些其他的优化，如延迟删除（Lazy Deletion）和扩容策略，以进一步提高性能和减少资源消耗。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "393f7399-ecfc-49ad-8e08-2dc6e0f6e8ea"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">分段分组</span></p>",
                            "note": "<div>为了实现高并发和线程安全，ConcurrentHashMap 使用了分段锁机制，也称为分段分组（Segmentation）。</div><div>ConcurrentHashMap 内部使用一个 Segment 数组来存储数据，每个 Segment 是一个独立的哈希表。Segment 数组的长度默认为 16，每个 Segment 都持有一个锁。因此，ConcurrentHashMap 的并发操作可以同时进行，每个线程可以独立地访问和修改不同的 Segment，避免了对整个数据结构的锁定。</div><div>具体的分段分组过程如下：</div><ol><li>ConcurrentHashMap 将哈希表划分为一定数量的 Segment。划分的方式是通过对并发级别进行取模操作，例如，并发级别为 16 时，ConcurrentHashMap 将使用 16 个 Segment。</li><li>每个 Segment 内部维护一个独立的哈希表，用于存储键值对。</li><li>当进行读取或写入操作时，ConcurrentHashMap 会根据键的哈希值确定应该访问哪个 Segment。</li><li>在读取操作时，只需要获取对应 Segment 的读锁，多个线程可以同时读取不同 Segment 的数据。</li><li>在写入操作时，需要获取对应 Segment 的写锁，以确保对该 Segment 的独占访问。这样，不同线程可以同时修改不同的 Segment，提高并发性能。</li></ol><div>通过将整个哈希表分成多个 Segment，并为每个 Segment 分配一个独立的锁，ConcurrentHashMap 在多线程环境下提供了更好的并发性能。不同线程可以独立地操作不同的 Segment，避免了对整个数据结构的串行访问。</div><div>需要注意的是，尽管 ConcurrentHashMap 提供了高并发性能，但在某些情况下，仍然需要考虑并发冲突和线程安全性。例如，如果多个线程同时对同一个键进行写入操作，仍然需要使用额外的同步手段来确保数据的一致性。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "3d85540d-9f28-4cff-ab8f-c78932c8c182"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "text": "<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">ArrayList</span></p>",
                    "richText": true,
                    "expand": true,
                    "isActive": false,
                    "uid": "651e6845-8c42-4205-bf94-bdefcb8e1f7c"
                },
                "children": [
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">底层数据结构</span></p>",
                            "note": "<div>ArrayList 的底层数据结构是数组（Array）。</div><div>在 Java 中，ArrayList 类实现了 List 接口，它是一个可变长度的动态数组。它内部使用一个数组作为存储元素的容器，并根据需要自动调整数组的大小。初始时，ArrayList 创建一个初始容量的数组，当元素数量超过当前容量时，它会自动进行扩容，以容纳更多的元素。</div><div>通过使用数组作为底层数据结构，ArrayList 具有以下特点：</div><ol><li>随机访问：由于底层是数组，ArrayList 允许通过索引快速访问和修改元素。通过索引，可以在常量时间内（O(1)）获取或设置特定位置的元素。</li><li>动态扩容：当元素数量超过当前容量时，ArrayList 会自动进行扩容。它会创建一个更大容量的新数组，并将元素从旧数组复制到新数组中。扩容操作的时间复杂度为 O(n)，其中 n 是当前元素的数量。</li><li>插入和删除：在数组中插入或删除元素时，需要移动其他元素以保持连续性。这种操作的时间复杂度为 O(n)，其中 n 是插入或删除点之后的元素数量。当需要频繁进行插入和删除操作时，ArrayList 的性能可能受到影响，因为需要移动大量元素。</li></ol><div>需要注意的是，ArrayList 不是线程安全的，不适合在多线程环境下进行并发操作。如果需要在多线程环境下使用，可以考虑使用 Vector 类或使用适当的同步手段来保证线程安全性。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "6945481f-20d5-4ae3-8739-b066da28d0df"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">ArrayList和LinkedList的区别</span></p>",
                            "note": "<div>ArrayList 和 LinkedList 是 Java 中常用的两种线性表实现，它们在底层数据结构、性能特点和适用场景上有所区别。</div><ol><li>底层数据结构：<ul><li>ArrayList 底层使用数组（Array）作为数据结构。它通过索引在数组中直接访问元素，支持快速的随机访问。</li><li>LinkedList 底层使用双向链表（Doubly Linked List）作为数据结构。每个节点包含元素值和指向前一个节点和后一个节点的指针。</li></ul></li><li>随机访问：<ul><li>ArrayList 支持快速的随机访问，通过索引可以在常量时间内获取或设置特定位置的元素。</li><li>LinkedList 对于随机访问不如 ArrayList 效率高，因为需要从头部或尾部开始遍历链表，时间复杂度为 O(n)，其中 n 是索引位置。</li></ul></li><li>插入和删除操作：<ul><li>ArrayList 在尾部进行插入和删除操作的性能较好，时间复杂度为 O(1)。但在中间位置进行插入和删除操作时，需要移动后续元素，时间复杂度为 O(n)。</li><li>LinkedList 在任意位置进行插入和删除操作的性能相对较好，时间复杂度为 O(1)，因为只需要修改节点的指针即可。</li></ul></li><li>内存占用：<ul><li>ArrayList 的内存占用比 LinkedList 低，因为它只需要存储元素和一个固定大小的数组，不需要额外的指针来连接节点。</li><li>LinkedList 的内存占用相对较高，因为它需要存储元素值和两个指针（前驱和后继节点）。</li></ul></li><li>迭代操作：<ul><li>ArrayList 在迭代操作上比较高效，因为可以通过索引直接访问元素，迭代过程中不需要频繁地遍历链表。</li><li>LinkedList 在迭代操作上性能较差，因为需要按照指针依次遍历链表中的元素。</li></ul></li></ol><div>综上所述，ArrayList 适用于需要快速随机访问和在尾部进行插入和删除操作的场景，而 LinkedList 适用于频繁进行插入和删除操作，或需要在链表中间进行插入和删除的场景。选择哪种实现取决于具体的使用需求和性能要求。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "300f7377-7c9c-4996-82fe-4cb3d7788078"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">CopyOnWriteArrayList的原理</span></p>",
                            "note": "<div>CopyOnWriteArrayList 是 Java 并发包（java.util.concurrent）中提供的一个线程安全的集合类，它的原理是\"写时复制\"（Copy-On-Write）。</div><ol><li>写时复制：<br>当需要对 CopyOnWriteArrayList 进行修改（如添加、修改或删除元素）时，它会创建一个新的数组，将原有数组的内容复制到新数组中，并在新数组上进行修改操作。这样，旧数组保持不变，读取操作仍然可以在旧数组上进行，不受修改操作的影响。</li><li>线程安全性：<br>``CopyOnWriteArrayList是线程安全的，因为它通过复制数组来实现并发访问的安全性。多个线程可以同时读取CopyOnWriteArrayList` 的内容，而不需要加锁。当有线程需要修改集合时，会进行一次数组的复制，确保修改操作不会影响到其他线程的读取操作。</li><li>高并发读取：<br>由于读取操作不需要加锁，并且可以在旧数组上进行，因此 CopyOnWriteArrayList 在高并发读取的场景中表现良好。多个线程可以同时读取集合的内容，不会发生读写冲突。</li><li>内存占用：<br>由于每次修改操作都会创建一个新的数组，并且修改操作是在新数组上进行的，因此 CopyOnWriteArrayList 的内存占用比较高。在有频繁修改操作的情况下，可能会消耗较多的内存。</li></ol><div>需要注意的是，CopyOnWriteArrayList 适用于读远远多于写的场景，例如读多写少或者读写分离的情况。如果有大量的写操作，可能会导致频繁的数组复制，影响性能。因此，在选择数据结构时，需要根据实际的使用场景和需求进行权衡和选择。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "4cdecc33-5af9-4897-93fc-6644dd8f9c78"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "text": "<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">多线程</span></p>",
                    "richText": true,
                    "expand": true,
                    "isActive": false,
                    "uid": "0026633d-2760-44ab-a665-79cb6c0f7056"
                },
                "children": [
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">创建线程的方式</span></p>",
                            "note": "<div>在 Java 中，有多种方式可以创建线程，以下是常用的几种方式：</div><ol><li>使用 Thread 类<br><br></li><li>实现 Runnable 接口<br><br></li><li>使用 Lambda 表达式简化 Runnable 接口的实现<br><br></li><li>实现 Callable 接口（可以返回结果）<br><br></li></ol><div>这些方式都可以创建线程，并在线程中执行指定的代码逻辑。其中，使用 Thread 类和实现 Runnable 接口是最常见的方式，而使用 Callable 接口可以将线程执行的结果返回。</div><div>需要注意的是，创建线程后，通过调用 start() 方法启动线程，线程会在自己的执行上下文中并行或交替执行。请确保在多线程环境下正确处理线程同步和共享数据的问题，以避免竞态条件和线程安全问题。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "fb170463-20d6-48bf-9f3a-e6df5c408e6d"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">线程的生命周期</span></p>",
                            "note": "<div>Java 线程的生命周期可以分为以下几个状态：</div><ol><li>新建（New）：线程被创建但尚未启动。此时线程处于新建状态。</li><li>可运行（Runnable）：线程调用 start() 方法后进入可运行状态，表示线程已经准备好执行，但并不意味着立即执行。在可运行状态下，线程等待获取 CPU 时间片以执行任务。</li><li>运行（Running）：当线程获得 CPU 时间片后，开始执行线程的任务代码。线程处于运行状态。</li><li>阻塞（Blocked）：线程在某些情况下会被阻塞，暂时停止执行。常见的阻塞情况包括等待锁、等待输入/输出、等待其他线程完成等。当阻塞条件解除时，线程会重新进入可运行状态，等待获取 CPU 时间片。</li><li>等待（Waiting）：线程在等待某个条件满足时进入等待状态，例如调用 wait() 方法、join() 方法或者 LockSupport.park() 方法。等待状态下的线程需要其他线程触发特定的条件来唤醒它。</li><li>超时等待（Timed Waiting）：线程在等待一段时间后自动进入超时等待状态，例如调用带有超时参数的 sleep() 方法、wait() 方法或者 join() 方法。</li><li>终止（Terminated）：线程执行完任务代码或者出现异常而终止，进入终止状态。终止状态的线程不再运行，其生命周期结束。</li></ol><div>在以上状态之间，线程可以根据不同的情况进行转换。例如，可运行状态的线程可以切换到运行状态或者阻塞状态，等待状态的线程可以切换到运行状态或者阻塞状态。线程的状态转换是由 Java 虚拟机（JVM）和操作系统负责管理和调度的。</div><div>需要注意的是，线程的状态不一定是线性的，可能会在不同的状态之间切换。线程的状态转换是由线程调度器和程序代码的执行情况决定的。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "afba1d6d-fa55-4add-9ed1-01cc76715272"
                        },
                        "children": [
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">New</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "3dc996de-2cf5-4f96-aa8d-ec54fbc65cce"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Runnable</span></p>",
                                    "note": "<div>在Java中，将线程从\"New\"状态（新建状态）转换为\"Runnable\"状态（就绪状态）可以通过调用线程对象的start()方法来实现。</div><div>当线程对象被创建后，处于\"New\"状态，此时线程对象已经被初始化，但还没有启动执行。要使线程进入\"Runnable\"状态，需要调用线程对象的start()方法。start()方法会启动线程并使其进入\"Runnable\"状态，等待操作系统调度执行。</div><div>示例代码如下所示：</div><pre>Thread thread = new Thread(new Runnable() {\n    @Override\n    public void run() {\n        // 线程要执行的代码\n        System.out.println(\"Thread is running\");\n    }\n});\n\nthread.start(); // 启动线程，使其进入就绪状态\n<br></pre><div>在调用start()方法后，线程会被放入线程调度器的就绪队列中，等待操作系统分配CPU资源来执行。一旦线程得到CPU资源，它将从\"Runnable\"状态转换为\"Running\"状态，并开始执行线程体中的代码。</div><div>需要注意的是，对于同一个线程对象，如果已经调用了一次start()方法使其进入\"Runnable\"状态，再次调用start()方法是无效的，会抛出IllegalThreadStateException异常。每个线程只能启动一次。</div>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "85094550-ef1b-45f2-aafd-1eb170212f02"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Running</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "cd3d732c-4aae-4abc-9068-15f9f896d361"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Blocked</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "49a6ca8a-35a8-47c9-8214-a1ea0dd659df"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Waiting</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "5d7ced02-30b7-427f-b9b8-c02da56ada72"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Timed Waiting</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "fdc1e9cd-ffa3-402d-ad1f-8cbe8d0fc255"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Terminated</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "3542f473-19e0-4fee-8e89-33c1bfc3048a"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">如何实现线程的同步</span></p>",
                            "note": "<div>在 Java 中，可以使用以下几种方式来实现线程的同步，以确保多个线程之间的共享资源被正确访问和修改：</div><ol><li>使用 synchronized 关键字：<ul><li>通过在方法声明中使用 synchronized 修饰符，可以确保多个线程无法同时执行该方法。<br><br></li><li>使用 synchronized 块来对关键代码块进行同步，只有一个线程可以进入该块执行。</li></ul></li><li>使用 ReentrantLock：<br>``ReentrantLock` 是一个可重入锁，它提供了与 synchronized 关键字类似的功能，但具有更灵活的使用方式。</li><li>使用 volatile 关键字：<br>``volatile` 关键字用于修饰共享变量，确保多个线程之间对该变量的修改可见性。它可以防止指令重排序优化，保证线程之间的数据同步。</li><li>使用原子类（Atomic Classes）：<br>Java 并发包提供了一系列的原子类，如 AtomicInteger、AtomicLong 等，它们提供了原子操作，可以确保对共享变量的操作是线程安全的。;<br><br></li></ol><div>这些方法都可以帮助实现线程的同步，保证多个线程之间的访问和修改是有序、可见且线程安全的。根据具体的需求和场景，选择适合的同步方式来确保线程安全性。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "64be6f3a-aeac-45d4-aeb8-4fd9191e0bc4"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">线程之间的通信方式</span></p>",
                            "note": "<div>在多线程编程中，线程之间需要进行通信以实现数据共享、协作和同步。以下是几种常见的线程间通信方式：</div><ol><li>共享变量：多个线程共享同一个变量，通过对该变量的读写来进行通信。需要注意的是，对共享变量的读写操作应该进行同步，以保证线程安全。</li><li>互斥锁（Mutex）：使用互斥锁来控制多个线程对共享资源的访问，一次只允许一个线程访问共享资源。常见的互斥锁有 synchronized 关键字和 ReentrantLock 类。</li><li>条件变量（Condition）：使用条件变量来实现线程的等待和唤醒操作，通常与互斥锁配合使用。通过调用条件变量的 await() 方法使线程等待，调用 signal() 或 signalAll() 方法唤醒等待的线程。</li><li>管道（Pipe）：通过管道在两个线程之间传递数据。一个线程将数据写入管道，另一个线程从管道读取数据。Java 提供了 PipedInputStream 和 PipedOutputStream 类来实现管道通信。</li><li>阻塞队列（Blocking Queue）：多个线程通过阻塞队列进行数据交换。一个线程将数据放入队列，另一个线程从队列中取出数据。阻塞队列提供了阻塞的插入和移除操作，确保线程在队列为空或队列已满时能够正确等待或阻塞。</li><li>wait() 和 notify()：使用对象的 wait() 和 notify() 方法进行线程间的等待和唤醒操作。一个线程调用对象的 wait() 方法进入等待状态，另一个线程调用对象的 notify() 方法唤醒等待的线程。</li><li>CountDownLatch：使用 CountDownLatch 实现线程的等待和唤醒。一个或多个线程等待计数器减到零，另一个线程执行完任务后将计数器减一。</li><li>Future 和 Callable：通过 Future 和 Callable 实现线程间的数据传递和结果获取。一个线程执行 Callable 任务并返回 Future 对象，另一个线程可以通过 Future 获取任务执行的结果。</li></ol><div>这些通信方式提供了不同的机制和适用场景，可以根据具体需求选择合适的方式来实现线程间的通信。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "50439d51-8370-4611-b98e-57d4dfdc0e6a"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">ThreadLocal作用</span></p>",
                            "note": "<div>Java中的ThreadLocal类提供了线程本地变量的功能。它允许每个线程都有自己的变量副本，即使是在共享同一个ThreadLocal对象的情况下，每个线程都可以独立地修改自己的副本，互不干扰。ThreadLocal主要具有以下几个作用：<br><br>1. 线程封闭性（Thread Confinement）：ThreadLocal可以将数据与线程关联，实现线程封闭性。通过将数据存储在ThreadLocal中，每个线程都可以独立地访问和修改自己的数据副本，而不会影响其他线程的数据。这对于并发编程中需要确保数据的线程安全性非常有用。<br><br>2. 线程上下文信息传递：在某些情况下，我们需要在多个方法之间传递线程上下文信息，例如用户身份验证信息、请求跟踪标识等。使用ThreadLocal可以方便地在同一个线程的不同方法之间共享这些线程上下文信息，而不需要显式地传递参数。<br><br>3. 线程级别的缓存：ThreadLocal可以用作线程级别的缓存，将一些计算结果或者资源存储在ThreadLocal中，供同一个线程的不同方法复用。这样可以避免重复计算或重复获取资源的开销，提高程序的性能。<br><br>需要注意的是，使用ThreadLocal时需要注意内存泄漏的问题。由于ThreadLocal的特性，如果没有适当地清理ThreadLocal中的数据，可能会导致内存泄漏，因为ThreadLocal的实例会一直持有对数据的引用，而这些数据对应的线程可能已经结束或不再需要这些数据。因此，使用完ThreadLocal后应该及时调用remove()方法或者使用ThreadLocal的remove()方法清理数据，以避免潜在的内存泄漏问题。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "f8c971ed-f00c-4b64-afe8-6fd5b85c26de"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "text": "<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">线程池</span></p>",
                    "richText": true,
                    "expand": true,
                    "isActive": false,
                    "uid": "addd4824-a23d-4e41-b890-c55fe6a0655b"
                },
                "children": [
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">工作原理</span></p>",
                            "note": "<div>Java 线程池是一种用于管理和重用线程的机制，它通过维护一组线程来执行任务，并提供了一些功能来优化线程的创建和销毁。线程池的工作原理如下：</div><ol><li>线程池的初始化：在创建线程池时，会指定线程池的初始大小（corePoolSize）、最大线程数（maximumPoolSize）、线程空闲时间（keepAliveTime）等参数。线程池会创建初始数量的线程，并将它们放入线程池中。</li><li>任务提交和执行：当有任务需要执行时，可以通过线程池的 submit() 或 execute() 方法将任务提交给线程池。线程池会从线程池中的线程中选择一个可用的线程来执行任务。如果线程池中的线程都在执行任务或者没有空闲线程，任务会被放入任务队列中等待执行。</li><li>任务队列：线程池维护一个任务队列，用于存放等待执行的任务。任务队列可以是有界队列（如 ArrayBlockingQueue）或无界队列（如 LinkedBlockingQueue）。当线程池中的线程都在执行任务时，新提交的任务会被放入任务队列中。</li><li>线程调度和执行：线程池中的线程会不断从任务队列中获取任务并执行。当一个线程完成一个任务后，它会获取下一个任务并继续执行。线程池会根据需要动态调整线程的数量，若任务较多，可以创建新的线程；若任务较少，可以销毁多余的线程。</li><li>线程池的扩展和回收：当任务提交给线程池时，如果线程池中的线程数已达到最大线程数，而任务队列也已满，线程池可以采取一些策略来处理这种情况。例如，可以拒绝新任务、调用者线程执行任务或者将任务放入调用者线程中执行。</li><li>线程的空闲时间和回收：线程池中的线程在执行完任务后，如果一段时间内没有新的任务可执行，这些线程会进入空闲状态。根据线程池的配置，空闲时间超过设定的时间后，空闲线程可能被回收，以减少资源消耗。</li></ol><div>通过使用线程池，可以避免频繁地创建与销毁线程的开销，并能更好地管理线程的执行。线程池提供了任务调度、线程复用、线程管理和资源控制等功能，能够提高应用程序的性能和稳定性。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "2855708b-6771-4b22-90bf-09533e009daf"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">状态</span></p>",
                            "note": "<div>Java 线程池有几种常见的状态，用于表示线程池的当前状态和执行情况。以下是线程池的几种状态：</div><ol><li>Running（运行状态）：线程池处于正常运行状态，可以接受新任务，并且已有的线程可以执行任务。</li><li>Shutdown（关闭状态）：线程池不再接受新任务，但是会继续执行已提交的任务。处于 Shutdown 状态时，调用线程池的 execute() 方法会被拒绝。</li><li>Stop（停止状态）：线程池不再接受新任务，并且会中断正在执行的任务。处于 Stop 状态时，调用线程池的 execute() 方法会被拒绝，并且正在执行的任务会被中断。</li><li>Tidying（整理状态）：线程池正在进行状态转换，例如从 Running 状态向 Shutdown 或 Stop 状态转换时，会进入 Tidying 状态。</li><li>Terminated（终止状态）：线程池已经终止，不再执行任务。线程池处于终止状态时，所有的任务都已完成或被取消，并且线程池中的线程已经被销毁。</li></ol><div>线程池的状态变迁通常遵循以下流程：</div><div>Running -&gt; Shutdown -&gt; Tidying -&gt; Terminated</div><div>或</div><div>Running -&gt; Stop -&gt; Tidying -&gt; Terminated</div><div>在线程池的状态转换过程中，可以通过调用线程池的方法（如 shutdown()、shutdownNow()）来显式地改变线程池的状态。线程池的状态可以通过调用线程池的方法（如 isShutdown()、isTerminated()）来查询。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "295cdad3-0c35-4b54-978c-66291ba00051"
                        },
                        "children": [
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Running</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "d95b2ab5-a716-435a-af00-d4b7c5ca13d4"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Shutdown</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "d677b8d7-37ed-49ad-8e5e-34c3f9e8a5a0"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Stop</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "da2f7708-9a72-4d4d-b696-2fcb1edeb42c"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Tidying</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "389cd94f-53c3-4d4f-8e0b-1b7d0c44d0a4"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Terminated</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "b891b364-a374-4880-b5c3-8104c86298be"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">拒绝策略</span></p>",
                            "note": "<div>线程池的拒绝策略是在线程池无法接受新任务时，对新提交的任务进行处理的策略。当线程池的任务队列已满且线程池中的线程数已达到最大线程数时，就会触发拒绝策略。Java 线程池提供了几种常见的拒绝策略：</div><ol><li>AbortPolicy（默认策略）：当线程池无法接受新任务时，会抛出 RejectedExecutionException 异常，拒绝新任务的提交。</li><li>CallerRunsPolicy：当线程池无法接受新任务时，会将任务返回给提交任务的线程执行。也就是说，提交任务的线程自己执行该任务，而不是交给线程池中的线程执行。</li><li>DiscardPolicy：当线程池无法接受新任务时，会直接丢弃该任务，不做任何处理。</li><li>DiscardOldestPolicy：当线程池无法接受新任务时，会丢弃队列中最旧的任务（即最先进入队列的任务），然后尝试再次提交新任务。</li></ol><div>除了以上四种常见的拒绝策略外，还可以通过实现 RejectedExecutionHandler 接口来自定义拒绝策略。自定义拒绝策略需要实现接口中的 rejectedExecution() 方法，该方法定义了当线程池无法接受新任务时的处理逻辑。</div><div>在创建线程池时，可以使用 ThreadPoolExecutor 类的构造函数来指定拒绝策略，默认为 AbortPolicy。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "76fd6dc4-7db0-4d6f-bd90-63b0d147a818"
                        },
                        "children": [
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">AbortPolicy（默认策略）</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "a42e0005-f7e5-4a1f-9db0-a67a2983347a"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">CallerRunsPolicy</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "191b514f-9005-4817-9f7f-e02da80e1148"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">DiscardPolicy</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "967f0891-5558-41c5-9604-1f80c7443de4"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">DiscardOldestPolicy</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "95bd99eb-f2a2-4694-a52a-3ff8fedc1461"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "text": "<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">java中的锁</span></p>",
                    "richText": true,
                    "expand": true,
                    "isActive": false,
                    "uid": "9148612e-ebf3-4f9b-ae5c-ed67b6928198"
                },
                "children": [
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">锁的种类</span></p>",
                            "note": "<div>在 Java 中，有几种常见的锁机制，用于实现多线程的同步和互斥操作。以下是一些常见的锁类型：</div><ol><li>synchronized 锁：synchronized 是 Java 内置的关键字，用于实现基本的锁机制。它可以应用于方法或代码块，确保同一时间只有一个线程可以访问被锁定的代码。synchronized 锁是可重入的，同一个线程可以多次获取同一个锁。</li><li>ReentrantLock 锁：ReentrantLock 是 java.util.concurrent.locks 包中提供的锁实现类。它提供了与 synchronized 相似的功能，但具有更强大的特性，如可重入性、公平性和条件等待。ReentrantLock 需要手动加锁和释放锁，可以更灵活地控制锁的获取和释放。</li><li>ReadWriteLock 锁：ReadWriteLock 是一个接口，定义了读写锁的基本操作。它支持多个线程同时读取共享资源，但在写入操作时需要独占锁。Java 提供了 ReadWriteLock 的实现类 ReentrantReadWriteLock。</li><li>StampedLock 锁：StampedLock 是 Java 8 引入的一种乐观读写锁机制。它提供了三种模式：读模式、写模式和乐观读模式。乐观读模式下，不会阻塞写入操作，但需要通过验证来确保读取的数据仍然有效。</li><li>LockSupport 锁：LockSupport 是 Java 提供的用于线程阻塞和唤醒的工具类。它可以通过 park() 方法阻塞线程，以及通过 unpark() 方法唤醒线程。LockSupport 并不是显式的锁，而是通过线程阻塞和唤醒来实现同步。</li><li>Condition 条件：Condition 是在 Lock 锁的基础上引入的，用于实现线程间的等待和通知机制。Condition 可以绑定到 Lock 上，通过 await() 方法使线程等待，通过 signal() 或 signalAll() 方法唤醒等待的线程。</li></ol>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "75224e20-ab06-4c4b-950c-b13876e17584"
                        },
                        "children": [
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">synchronized的实现原理</span></p>",
                                    "note": "<div>synchronized 是 Java 中的关键字，用于实现线程的同步和互斥。synchronized 的实现原理是基于 Java 对象头（Object Header）和内置锁（Intrinsic Lock）的机制。</div><div>当一个线程进入 synchronized 代码块时，它会尝试获取对象的内置锁。如果该锁没有被其他线程占用，则该线程成功获取锁，并进入临界区执行同步代码。如果锁已被其他线程占用，那么该线程就会被阻塞，直到获取到锁为止。</div><div>在 Java 对象头中，包含着与对象相关的元信息，其中的一部分用于存储锁的信息。具体来说，对象头中包含了一个标记字段用于表示对象的锁状态，以及一个指向持有该锁的线程的指针。</div><div>当一个线程成功获取到锁时，它会将锁的标记字段设置为已锁定的状态，并将持有锁的线程指针设置为当前线程。这样其他线程在尝试获取同一个锁时就会失败，进入阻塞状态。</div><div>当持有锁的线程执行完同步代码块或方法时，会释放锁，将锁的标记字段设置为未锁定状态，同时清空持有锁的线程指针。这样其他线程就有机会获取该锁并执行同步代码。</div><div>synchronized 的实现原理确保了同一时间只有一个线程可以执行被 synchronized 保护的临界区代码，从而保证了线程的安全性。此外，synchronized 还具有可重入性，即同一线程可以多次获取同一个锁，避免了死锁的发生。</div><div>需要注意的是，synchronized 有两种用法：synchronized 方法和 synchronized 块。对于 synchronized 方法，它会隐式地获取对象的内置锁；而对于 synchronized 块，需要手动指定锁对象。无论是哪种用法，都是基于相同的内置锁机制实现的。</div>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "d8ee27ab-1d87-4b29-947f-eb9bae11f284"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">RentrantLock的实现原理</span></p>",
                                    "note": "<div>ReentrantLock 是 Java 语言提供的一个可重入锁（Reentrant Lock）实现类，它与 synchronized 关键字相比提供了更灵活的锁控制。ReentrantLock 的实现原理基于 AQS（AbstractQueuedSynchronizer）框架。</div><div>AQS 是一个用于构建锁和同步器的框架，ReentrantLock 内部使用 AQS 来管理锁的状态和线程的排队。AQS 使用一个 FIFO 的双向队列（CLH 队列）来保存等待获取锁的线程，并使用一个整型变量（state）来表示锁的状态。</div><div>当一个线程尝试获取 ReentrantLock 锁时，它会首先尝试通过 CAS（Compare and Swap）操作将 state 从 0 修改为 1，表示获取锁成功。如果获取锁失败，线程会被加入到等待队列中，并进入阻塞状态。</div><div>如果一个线程已经持有了 ReentrantLock 锁，那么它可以再次获取该锁，而无需阻塞等待。ReentrantLock 使用一个计数器（holdCount）来记录持有锁的次数，每次获取锁时计数器加一，释放锁时计数器减一。只有当计数器归零时，锁才会完全释放。</div><div>当一个线程释放 ReentrantLock 锁时，它会尝试唤醒等待队列中的下一个线程，使其有机会获取锁。唤醒操作会通过 LockSupport.park() 和 LockSupport.unpark() 方法实现。</div><div>ReentrantLock 还提供了公平性和非公平性两种模式。在公平模式下，等待时间最长的线程会优先获取锁，而非公平模式下，锁的获取是无序的。公平模式可以避免线程饥饿的问题，但会降低吞吐量。</div><div>ReentrantLock 还支持条件变量（Condition），可以通过 Condition 对象实现线程间的等待和唤醒。Condition 对象是与锁关联的，只有持有相应锁的线程才能调用 Condition 的 await()、signal() 和 signalAll() 方法。</div><div>总结起来，ReentrantLock 的实现原理是基于 AQS 框架，使用 CAS 操作和等待队列来实现线程的同步和互斥。它支持可重入性、公平性和条件等待，提供了更灵活和高级的锁控制功能。</div>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "ed8c6036-5b71-440b-bff6-3818e0a09194"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">ReadWriteLock 锁</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "d7280a52-466b-4628-9067-a702f08b0677"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">StampedLock 锁</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "2ed05657-3267-475a-bf24-fb8a255c6dc5"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">LockSupport 锁</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "089e6fc1-1f2e-4c2e-a6ab-d3d78cc1bb36"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Condition 条件</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "1127e907-0083-4944-810e-a36f05d74a66"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">volatile关键字的作用</span></p>",
                            "note": "<div>volatile 是 Java 中的关键字，用于修饰变量。它的作用是确保被修饰的变量在多线程环境下的可见性和禁止重排序。</div><ol><li>可见性：当一个变量被声明为 volatile 时，它保证了在一个线程中对该变量的修改对其他线程是可见的。也就是说，当一个线程修改了一个 volatile 变量的值，其他线程能够立即看到最新的值，而不是使用缓存中的旧值。</li><li>禁止重排序：volatile 关键字还可以禁止编译器和处理器对被修饰变量的指令重排序。指令重排序是为了优化程序的执行效率，在单线程环境下不会产生问题。但在多线程环境下，指令重排序可能会导致线程安全问题，因为它打乱了程序的原始顺序。</li></ol><div>使用 volatile 关键字修饰的变量，会告诉编译器和处理器不要对该变量的读写操作进行重排序，以确保程序的正确性。</div><div>需要注意的是，虽然 volatile 可以保证可见性和禁止重排序，但它并不能替代锁（synchronized 或 ReentrantLock）的使用。volatile 关键字适用于对单个变量的读写操作，而对于复合操作、原子性操作和线程间的同步，仍需要使用锁来保证线程安全。</div><div>总结起来，volatile 关键字的作用是保证被修饰变量在多线程环境下的可见性和禁止重排序。它是一种轻量级的同步机制，适用于对单个变量的读写操作。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "222e636f-0bc8-4249-854c-6c3597e7cf81"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">锁的升级机制</span></p>",
                            "note": "<div>在 Java 中，锁的升级机制指的是从低级别的锁到高级别的锁的转换过程。这个机制是为了在不同场景下提供更好的性能和灵活性。</div><div>Java 中的锁升级机制可以分为两种常见的情况：</div><ol><li>轻量级锁（Lightweight Lock）升级为重量级锁（Heavyweight Lock）：<br>当一个线程尝试获取一个被轻量级锁保护的对象时，如果该对象已经被其他线程获取了轻量级锁，那么当前线程会尝试进行自旋，即反复尝试获取锁而不放弃 CPU 资源。如果自旋一定次数后仍无法获取锁，轻量级锁就会升级为重量级锁。重量级锁使用操作系统提供的互斥量来实现，线程在无法获取锁时会进入阻塞状态，释放 CPU 资源给其他线程。</li><li>偏向锁（Biased Lock）升级为轻量级锁或重量级锁：<br>偏向锁是为了解决无竞争情况下的锁操作性能问题。当一个线程获得一个对象的锁时，会将对象头中的标记字段设置为偏向锁，并将线程的 ID 记录在对象头中。如果在接下来的执行过程中，没有其他线程试图获取该对象的锁，那么该锁会一直保持偏向状态，不会升级。但是，如果其他线程尝试获取该对象的锁，偏向锁就会升级为轻量级锁或重量级锁，具体升级的方式取决于竞争情况和具体的 JVM 实现。</li></ol>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "95db9b2d-2966-4c2c-b9bb-1d38894bb767"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "text": "<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">JVM运行时数据区</span></p>",
                    "richText": true,
                    "expand": true,
                    "isActive": false,
                    "uid": "7188769d-92d8-40e1-8d70-09828180dd2b"
                },
                "children": [
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">内存分布情况</span></p>",
                            "note": "<div>JVM（Java虚拟机）的内存分布可以分为以下几个主要区域：</div><ol><li>程序计数器（Program Counter Register）：<br>程序计数器是一块较小的内存区域，它用于存储当前线程执行的字节码指令的地址。每个线程都有一个独立的程序计数器，用于记录线程当前执行的位置，以便在线程切换后能够恢复执行。</li><li>Java 虚拟机栈（Java Virtual Machine Stacks）：<br>Java 虚拟机栈是每个线程独有的，用于存放线程执行方法的局部变量、操作数栈、方法参数以及方法调用和返回的信息。每个方法在执行时都会创建一个栈帧（Stack Frame），栈帧包含了方法的局部变量和操作数栈等信息。</li><li>本地方法栈（Native Method Stack）：<br>本地方法栈与虚拟机栈类似，但是它用于执行 Native 方法（使用非 Java 语言编写的方法）。本地方法栈也是每个线程独有的，用于支持 Native 方法的调用和执行。</li><li>堆（Heap）：<br>堆是 Java 虚拟机管理的最大的一块内存区域，用于存放对象实例和数组。堆是被所有线程共享的，被划分为新生代和老年代等不同的区域。大部分的对象实例都在堆中分配和回收。</li><li>方法区（Method Area）：<br>方法区用于存储类的结构信息（如类的字节码、静态变量、常量池等）和方法的字节码。方法区也是被所有线程共享的，它包含了所有已加载的类信息。</li><li>运行时常量池（Runtime Constant Pool）：<br>运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。在运行时，一些符号引用可能会被解析为直接引用，用于执行方法的调用和字段的访问。</li><li>直接内存（Direct Memory）：<br>直接内存并不是 JVM 运行时数据区的一部分，但是它与堆内存密切相关。直接内存是通过使用 Native 函数库直接分配的内存区域，主要用于 NIO（New Input/Output）操作，通过 ByteBuffer 进行读写。</li></ol><div>需要注意的是，JVM 的内存分布在不同的 JVM 实现中可能有所差异，上述描述是基于一般情况下的内存布局。此外，在 Java 8 及之前的版本中，方法区被称为永久代（Permanent Generation），而在 Java 8 之后，永久代被元空间（Metaspace）所取代。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "0595d13b-f8ea-4349-8693-c4b2764b0208"
                        },
                        "children": [
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">程序计数器</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "0973790d-7401-4d2e-97e2-43600e0aa941"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Java 虚拟机栈</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "066b4efa-a719-4caf-b014-1017662f57d4"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">子主题 3</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "5fb3e45c-6342-46e8-bca2-e11358a7f084"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">子主题 4</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "dcba451f-84ed-40c0-9f9b-a6461e439d24"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">本地方法栈作用</span></p>",
                            "note": "<div>JVM 的本地方法栈（Native Method Stack）用于支持执行 Native 方法，即使用非 Java 语言编写的方法。本地方法栈是每个线程独有的，与虚拟机栈（Java Virtual Machine Stack）类似，但是用于执行 Native 方法而不是 Java 方法。</div><div>本地方法栈的主要作用包括：</div><ol><li>执行 Native 方法：本地方法栈用于存储 Native 方法的调用和执行信息。当 Java 代码调用 Native 方法时，虚拟机会将当前线程切换到本地方法栈，并将控制权传递给本地方法执行。</li><li>分配和管理本地资源：本地方法栈也可以用于分配和管理本地资源。Native 方法通常需要与底层系统或外部库进行交互，可能涉及文件操作、网络通信、硬件访问等。本地方法栈可以为 Native 方法分配所需的资源，并在方法执行完毕后进行资源的释放和清理，以确保资源的正确管理。</li><li>调用 Java 方法：本地方法栈还可以用于从 Native 方法中调用 Java 方法。当 Native 方法需要调用 Java 方法时，虚拟机会将当前线程切换回虚拟机栈，并在虚拟机栈上创建新的栈帧用于执行 Java 方法。</li></ol><div>总体而言，本地方法栈是为支持执行 Native 方法而设计的，它提供了执行 Native 方法的环境和资源管理机制。通过本地方法栈，Java 程序能够与底层系统进行交互，并利用非 Java 语言编写的方法来扩展和优化程序的功能。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "6f625150-2fc2-40c2-a088-7ccbc13fd52d"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">程序计数器作用</span></p>",
                            "note": "<div>程序计数器（Program Counter Register）是一块较小的内存区域，它在 JVM 中起着重要的作用。</div><div>程序计数器的主要作用如下：</div><ol><li>记录当前线程执行的字节码指令地址：程序计数器会存储当前线程正在执行的字节码指令的地址或索引。它相当于一个指针，指向当前线程正在执行的字节码指令，用于指示下一条需要执行的指令。</li><li>线程切换的恢复点：由于线程切换是由操作系统进行调度的，当一个线程被切换出去后，再次切换回来时，需要知道上次执行的位置。程序计数器记录了每个线程的执行位置，因此可以在线程切换后正确地恢复执行。</li><li>分支、循环、异常处理等控制流的支持：程序计数器可以帮助控制流跳转。在分支、循环、异常处理等情况下，程序计数器可以确保程序按照正确的控制流进行执行，跳转到相应的目标位置。</li><li>方法调用和返回的支持：程序计数器记录了方法调用和返回的信息。当一个方法调用另一个方法时，程序计数器会保存当前方法的返回地址，以便在被调用方法执行完毕后返回到正确的位置。</li></ol><div>需要注意的是，程序计数器是每个线程独立存在的，即每个线程都有自己的程序计数器。这样可以保证每个线程都能独立地跟踪和管理自己的执行状态，从而实现线程之间的独立性。</div><div>总结起来，程序计数器在 JVM 中扮演着记录当前线程执行位置、支持控制流跳转、支持方法调用和返回等功能的重要角色。它是实现线程独立性和控制流管理的关键组成部分。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "cdc9bf22-5f9f-4415-808a-810b2eb028ee"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">类存放在哪里</span></p>",
                            "note": "<div>在 Java 虚拟机（JVM）中，类的定义和相关信息通常存放在方法区（Method Area）中，也称为元空间（Metaspace）。</div><div>方法区是 JVM 运行时数据区域的一部分，用于存储类的结构信息、静态变量、常量池、方法字节码等。每个加载的类都会在方法区中创建一个类对象（Class Object），该对象包含了类的元数据，如类的名称、父类、接口、字段、方法等。</div><div>类的加载过程包括加载、验证、准备、解析和初始化等阶段。在加载阶段，类的字节码被读入内存，并在方法区中创建类对象和其他相关数据结构。在初始化阶段，执行类的静态初始化代码，为静态字段赋初值等操作。</div><div>需要注意的是，方法区在 Java 8 及之前的版本中被称为永久代（Permanent Generation），而在 Java 8 之后，永久代被元空间所取代。元空间的分配不再受限于固定大小的永久代，而是使用本地内存。这样可以更好地管理类的元数据，避免了永久代出现的内存溢出问题。</div><div>总结而言，类的定义和相关信息存放在 JVM 的方法区（元空间）中。方法区是一块专门用于存储类的结构信息、常量池、方法字节码等的内存区域。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "2c644afd-8de8-4d10-8960-ea1fdac0bc39"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">局部变量存放在哪里</span></p>",
                            "note": "<div>局部变量的存放位置取决于其所在的方法或代码块的作用域和生命周期。在 Java 虚拟机（JVM）中，局部变量的存放位置可以是以下几个地方：</div><ol><li>栈帧（Stack Frame）：<br>局部变量的大部分存储在栈帧中，也称为栈上分配。每个方法在执行时都会创建一个栈帧，栈帧包含了方法的局部变量、操作数栈、方法参数等信息。局部变量在栈帧中分配的内存空间是根据其类型确定的，并且在方法执行完毕后会被立即释放。</li><li>寄存器：<br>一些局部变量可以存储在 CPU 的寄存器中，以提高访问速度。寄存器是 CPU 内部的快速存储区域，可以直接访问，速度比栈帧上的内存访问更快。但是，寄存器的数量有限，只有少量的局部变量能够存放在寄存器中。</li><li>堆中的对象：<br>如果局部变量是对象引用，并且对象是在堆上分配的，则存储在栈帧中的局部变量将包含对堆上对象的引用。实际的对象数据存储在堆中，而栈帧中的局部变量仅保存了对对象的引用。</li></ol><div>需要注意的是，局部变量的生命周期通常是在其所在的方法或代码块执行期间。一旦方法或代码块执行完毕，栈帧和其中的局部变量将被释放，而堆中的对象可能会在稍后的垃圾回收过程中被回收。</div><div>总结而言，大部分局部变量存放在栈帧中，少量局部变量可能存放在寄存器中。如果局部变量是对象引用，则栈帧中的局部变量保存了对堆中对象的引用。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "3f34767c-9857-40b9-b52e-627f5db2b23d"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">xmx, xms参数的作用</span></p>",
                            "note": "<div>在Java中，`-Xmx`、`-Xms`、`-Xmn`和`-XX:SurvivorRatio`是用于调整JVM内存分配的参数。下面是它们的含义和计算方法：</div><div><br></div><div>1. `-Xmx`：指定JVM最大可用内存。它设置了Java堆的最大大小。例如，`-Xmx2g`表示将最大可用内存设置为2GB。</div><div><br></div><div>2. `-Xms`：指定JVM初始分配的内存大小。它设置了Java堆的初始大小。例如，`-Xms512m`表示初始分配512MB的内存。</div><div><br></div><div>3. `-Xmn`：指定年轻代（Young Generation）的大小。年轻代是Java堆的一部分，用于存放新创建的对象。`-Xmn`通常设置为整个堆内存的一部分，具体大小根据应用程序的需求和垃圾收集器的特性来确定。例如，`-Xmn256m`表示将年轻代的大小设置为256MB。</div><div><br></div><div>4. `-XX:SurvivorRatio`：指定Eden区和Survivor区的大小比例。Survivor区是年轻代中的一部分，用于存放经过一次垃圾回收后仍然存活的对象。`-XX:SurvivorRatio=2`表示将Eden区和Survivor区的大小比例设置为2:1，即两个Survivor区的总大小为Eden区的一半。</div><div><br></div><div>计算最小内存和Survivor内存的公式如下：</div><div><br></div><div>最小内存 = Java堆的初始大小（-Xms） + Metaspace（元空间）大小 + 线程栈的大小</div><div><br></div><div>Survivor内存 = 年轻代大小（-Xmn） * Survivor区的大小比例（-XX:SurvivorRatio）</div><div><br></div><div>需要注意的是，以上计算只是一个基本的估算，实际的内存使用可能受到多种因素的影响，包括应用程序的特性、垃圾收集器的选择和系统的负载等。因此，最好根据具体的应用场景和性能需求进行调整和测试，以找到最合适的内存配置。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "e9858f4f-106b-4c67-8369-eb0ce5850717"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "text": "<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">JVM类加载机制</span></p>",
                    "richText": true,
                    "expand": true,
                    "isActive": false,
                    "uid": "1e535c84-3e20-4301-96c9-bf3152eaaa9b"
                },
                "children": [
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">类加载器</span></p>",
                            "note": "<div>JVM（Java 虚拟机）中的类加载器（ClassLoader）是负责将类的字节码加载到 JVM 中并生成对应的 Class 对象的组件。类加载器是 JVM 的重要组成部分，它的主要任务是根据类的名称定位并加载类的字节码，使得这些类可以在运行时被 JVM 使用。</div><div>JVM 中的类加载器可以分为以下几种类型：</div><ol><li>启动类加载器（Bootstrap Class Loader）：<br>启动类加载器是 JVM 内置的类加载器，它负责加载 Java 核心类库，如 java.lang、java.util 等。启动类加载器是由 JVM 实现的一部分，通常由本地代码实现，不是一个普通的 Java 类。</li><li>扩展类加载器（Extension Class Loader）：<br>扩展类加载器是负责加载 Java 扩展库（extensions），它加载的路径由系统属性 java.ext.dirs 指定，默认加载 $JAVA_HOME/lib/ext 目录下的 JAR 文件。扩展类加载器是由 sun.misc.Launcher$ExtClassLoader 实现的。</li><li>应用程序类加载器（Application Class Loader）：<br>应用程序类加载器是最常见的类加载器，也称为系统类加载器。它负责加载应用程序的类路径（classpath）下的类，包括开发者编写的类和第三方库。应用程序类加载器是由 sun.misc.Launcher$AppClassLoader 实现的。</li></ol><div>除了这些标准的类加载器，JVM 还支持自定义的类加载器，开发者可以通过继承 java.lang.ClassLoader 类来创建自己的类加载器。自定义类加载器可以根据特定需求加载类，例如从非标准的位置加载类文件、实现类似热部署的功能等。</div><div><br></div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "8c37019b-f288-418f-a299-c831bb305959"
                        },
                        "children": [
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">启动类加载器</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "1ceb90f3-78a1-4c57-9925-9bf43e0b1333"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">扩展类加载器</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "e44fd05d-26c0-4917-8227-9cffd8878fed"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">应用程序类加载器</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "f2881425-71bf-45a7-9cdd-b3f1bae276ad"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">自定义（继承 java.lang.ClassLoader） </span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "a46a8875-afb9-451a-8076-e48ab33cdc6a"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">类加载的过程</span></p>",
                            "note": "<div>类加载是将类的字节码加载到 JVM 中并生成对应的 Class 对象的过程。类加载过程通常包括加载、验证、准备、解析和初始化等阶段。</div><ol><li>加载（Loading）：<br>加载是类加载过程的第一阶段。在加载阶段，类加载器根据类的全限定名（包括包名和类名）来定位并读取类的字节码文件，将字节码数据加载到内存中。加载阶段的结果是在内存中生成一个代表该类的 Class 对象。</li><li>验证（Verification）：<br>验证是类加载过程的第二阶段。在验证阶段，对加载的字节码进行验证，确保其符合 JVM 规范和安全要求。验证的内容包括语法检查、字节码验证、符号引用验证等。验证阶段的目的是保证加载的字节码是合法且安全的。</li><li>准备（Preparation）：<br>准备是类加载过程的第三阶段。在准备阶段，为类的静态变量（被 static 修饰的变量）分配内存空间，并设置默认初始值。这些静态变量在此阶段被赋予初始值，例如数值类型的默认值为 0，对象引用的默认值为 null 等。</li><li>解析（Resolution）：<br>解析是类加载过程的第四阶段。在解析阶段，将符号引用替换为直接引用。符号引用是一种在编译时使用的编译器常量，它通过符号引用可以定位到目标的具体内存地址。解析阶段将符号引用转换为直接引用，使得程序可以直接访问目标对象。</li><li>初始化（Initialization）：<br>初始化是类加载过程的最后阶段。在初始化阶段，对类的静态变量进行初始化，执行静态代码块和静态初始化器。初始化阶段的执行顺序是按照静态变量和静态代码块在源代码中的顺序来决定的。初始化阶段完成后，类就可以被正常使用。</li></ol><div>需要注意的是，类加载的过程是按需进行的，即在首次使用类时才会触发对应的加载、验证、准备、解析和初始化。此外，类加载过程是具有层次性的，通过双亲委派模型，由上层类加载器委派给下层类加载器进行加载，保证类的唯一性和安全性。</div><div>总结而言，类加载的过程包括加载、验证、准备、解析和初始化等阶段。通过类加载器将类的字节码加载到内存中，并生成对应的 Class 对象，使得类可以在 JVM 中被使用。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "f7a6e598-6d4f-49db-8c17-0a670abf980f"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">双亲委派模型</span></p>",
                            "note": "<div>类加载器采用了双亲委派模型（Delegation Model）来保证类的加载的安全性和一致性。根据这个模型，当一个类加载器收到类加载请求时，它首先将加载任务委派给其父类加载器，只有在父类加载器无法加载时，才由子类加载器尝试加载。这样可以避免类的重复加载和不安全的类替换。<br><br>双亲委派模型（Delegation Model）是 Java 类加载机制中的一种设计模式，用于保证类的加载的安全性和一致性。该模型基于父子关系的类加载器之间的协作，使得类加载器在加载类时按照一定的规则进行委派和协作。<br><br></div><div>在双亲委派模型中，当一个类加载器收到类加载请求时，它首先将加载任务委派给其父类加载器。只有当父类加载器无法加载该类时，才由子类加载器尝试加载。这个委派的过程会一直向上递归，直到达到顶层的启动类加载器（Bootstrap Class Loader）为止。<br><br></div><div>该模型的核心思想是避免类的重复加载和不安全的类替换。通过委派给父类加载器，可以确保类只被加载一次，避免重复加载。同时，由于父类加载器无法加载来自子类加载器的类，因此可以防止不同类加载器加载同名类的冲突。</div><div>具体的委派过程如下：</div><ol><li>当一个类加载器接收到加载类的请求时，它首先检查是否已经加载过该类。如果已加载，则直接返回对应的 Class 对象。</li><li>如果尚未加载该类，则将加载请求委派给父类加载器。</li><li>父类加载器根据委派模型，递归地将加载请求委派给其父类加载器，直到达到启动类加载器。</li><li>如果启动类加载器无法加载该类，委派回原加载器的子类加载器。</li><li>子类加载器尝试加载类，如果成功加载，则返回对应的 Class 对象；如果无法加载，则继续委派给父类加载器的下一个子类加载器。</li><li>如果所有的父类加载器都无法加载该类，则抛出 ClassNotFoundException。</li></ol><div>通过双亲委派模型，可以保证类的加载具有层次性和一致性，避免类的重复加载和冲突，同时提高了安全性。这个模型也允许开发者通过自定义类加载器来实现特定的加载需求，例如从非标准位置加载类文件、实现类似热部署的功能等。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "46a411a9-6d0e-4daa-8cbf-ae699a2237dd"
                        },
                        "children": [
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">破坏双亲委派</span></p>",
                                    "note": "<div>破坏Java的双亲委派机制可能导致以下问题和不利影响：</div><ol><li>类冲突和加载冲突：双亲委派机制是Java类加载器的核心原则，它通过层级结构和委派机制来保证类的唯一性和一致性。如果破坏了双亲委派机制，可能会导致不同类加载器加载同一个类，出现类冲突和加载冲突的问题，造成类的多次定义和不可预测的行为。</li><li>安全性问题：双亲委派机制能够防止恶意代码通过替换核心类库来执行恶意操作。如果破坏了双亲委派机制，恶意代码可能会绕过核心类库的安全检查，导致安全漏洞和风险。</li><li>平台一致性问题：Java的核心类库和标准API是通过双亲委派机制进行加载的，这可以确保不同Java平台的一致性和兼容性。如果破坏了双亲委派机制，可能会导致不同平台之间的行为差异，破坏了Java的可移植性和跨平台特性。</li><li>垃圾回收问题：Java的垃圾回收器（Garbage Collector）通常会依赖于双亲委派机制来确定类的可达性和回收。如果破坏了双亲委派机制，可能会导致垃圾回收器无法正确地回收无用的类和对象，造成内存泄漏和资源浪费。</li></ol>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "9b5059f6-9708-46f4-b917-9a84f890e1fc"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "text": "<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Jdk命令</span></p>",
                    "note": "<div>1. jps：jps（Java Virtual Machine Process Status Tool）是Java虚拟机提供的一个命令行工具，用于列出当前系统中正在运行的Java进程。它可以显示Java进程的进程ID（PID）和主类名称，方便开发人员查找和监视Java进程。</div><div><br></div><div>2. jstat：jstat 是Java虚拟机（JVM）提供的一个命令行工具，用于监视和收集与Java堆和垃圾回收相关的统计信息。它可以提供实时的内存、垃圾回收、类加载、线程等方面的数据。通过 jstat，可以了解应用程序的内存使用情况、垃圾回收性能等，以进行性能调优和故障排查。</div><div><br></div><div>3. jstack：jstack 是Java虚拟机提供的一个命令行工具，用于生成Java进程的线程转储信息。它可以输出Java进程中每个线程的堆栈跟踪，包括线程状态、调用栈信息等。jstack 常用于分析应用程序的死锁、线程挂起等问题，在故障排查和性能调优中发挥重要作用。</div><div><br></div><div>4. jmap：jmap 是Java虚拟机提供的一个命令行工具，用于生成Java堆的转储文件（heap dump）。它可以将Java进程的内存信息转储到文件中，包括对象实例、类信息、堆栈跟踪等。通过分析堆转储文件，可以了解应用程序的内存使用情况、对象分布、内存泄漏等问题，对于内存分析和调优非常有用。</div><div><br></div>",
                    "richText": true,
                    "expand": true,
                    "isActive": false,
                    "uid": "f15f5276-3f97-4609-b8c8-3483fe2ae05b"
                },
                "children": [
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">jps</span></p>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "b434303a-c96e-487c-a484-81ec5be1ed5d"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">jstat</span></p>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "dfa60075-29b1-47b0-b62c-b44e46fea4e1"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">jstack</span></p>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "9e081460-7eeb-49b4-a2fa-936f51d7e940"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">jmap</span></p>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "e3f3ba61-7b24-4a41-8ba0-9df297b6360a"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "text": "<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">JVM垃圾回收机制</span></p>",
                    "richText": true,
                    "expand": true,
                    "isActive": false,
                    "uid": "6600ac40-0412-4760-b181-4ff0fd1e5b66"
                },
                "children": [
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">哪些内存需要回收</span></p>",
                            "note": "<div>JVM（Java 虚拟机）中的垃圾回收器（Garbage Collector）主要负责回收不再使用的对象所占用的内存空间。JVM中需要回收的内存包括以下几个方面：</div><ol><li>堆内存（Heap Memory）：<br>堆内存是 JVM 中存放对象实例的区域，其中包括新生代（Young Generation）和老年代（Old Generation）。垃圾回收器主要负责回收堆内存中不再使用的对象。当对象没有被引用时，垃圾回收器会标记这些对象为垃圾，并回收它们所占用的内存空间。</li><li>方法区（Method Area）：<br>方法区是 JVM 中存放类信息、常量、静态变量等数据的区域。在方法区中，垃圾回收器主要负责回收无用的常量和无用的类。当一个类不再被使用时，垃圾回收器会将其从方法区中移除，并回收相应的内存空间。</li><li>栈内存（Stack Memory）：<br>栈内存用于存放方法调用的局部变量、方法参数、操作数栈等数据。栈内存的回收由线程自行管理，当一个方法执行结束或线程终止时，栈帧中的数据会被自动释放，无需垃圾回收器介入。</li></ol><div>除了上述的主要内存区域，还有一些其他的内存区域也需要进行回收，例如：</div><ol><li>常量池（Constant Pool）：<br>常量池是方法区的一部分，用于存放字符串常量、类和接口的符号引用等。在垃圾回收过程中，无用的常量会被标记并回收。</li><li>本地方法栈（Native Method Stack）：<br>本地方法栈用于存放 Java 本地方法（Native Method）的数据。本地方法栈的管理和回收通常由操作系统负责。</li></ol><div>需要注意的是，虽然垃圾回收器会回收不再使用的对象所占用的内存空间，但具体的回收时机和策略是由垃圾回收器的算法和配置决定的。不同的垃圾回收器可能采用不同的回收算法和策略，例如标记-清除（Mark and Sweep）、复制（Copying）、标记-整理（Mark and Compact）等，以达到最优的性能和内存利用效率。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "0a665bbf-fc5c-4da6-ae71-48a5b21b5912"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">如何定义垃圾</span></p>",
                            "note": "<div>在 JVM 中，垃圾是指不再被程序使用的对象或无法访问到的对象。垃圾对象是不再需要的对象，占据内存空间却没有被程序使用，造成资源浪费。</div><div>在 Java 中，垃圾的定义是基于垃圾回收（Garbage Collection）的概念，主要通过以下方式来判断一个对象是否为垃圾：</div><ol><li>引用计数（Reference Counting）：<br>引用计数是一种简单的垃圾回收算法，它为每个对象维护一个引用计数器，记录该对象被引用的次数。当引用计数器为 0 时，表示该对象不再被引用，即可判定为垃圾。然而，引用计数算法无法解决循环引用的问题，即使一组对象之间互相引用，但与程序的根节点无关，也会被错误地判定为垃圾。</li><li>可达性分析（Reachability Analysis）：<br>可达性分析是 Java 中主要采用的垃圾回收算法。它以一组称为\"GC Roots\"的对象作为起始点，通过遍历对象的引用关系，判断对象是否可达。如果对象与 GC Roots 不可达，则被认为是垃圾。常见的 GC Roots 包括虚拟机栈中的局部变量、静态变量、方法区中的类静态属性等。</li></ol><div>通过可达性分析，一旦对象不再与 GC Roots 相连，就可以判定为垃圾。垃圾回收器会周期性地执行可达性分析，标记需要回收的垃圾对象，并在后续的垃圾回收阶段进行回收操作。</div><div>需要注意的是，Java 中的垃圾回收是自动进行的，程序员无需显式地释放对象。垃圾回收器负责在适当的时候回收垃圾对象所占用的内存空间，以提高内存利用效率和程序的性能。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "fe65ff74-29cd-46f8-b172-59e33bd3a960"
                        },
                        "children": [
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">引用计数</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "5f0e0361-ea87-458b-b98a-06bf0bb15b1b"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">可达性分析</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "0d92fc52-f5a0-4c4a-8216-ce119d72a5c5"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">怎么回收垃圾</span></p>",
                            "note": "<div>JVM使用垃圾回收器（Garbage Collector）来回收不再使用的对象。垃圾回收器负责自动识别和回收垃圾对象，释放它们所占用的内存空间。</div><div>需要注意的是，JVM中的垃圾回收过程是自动进行的，由垃圾回收器负责管理。垃圾回收器的具体行为和策略取决于所采用的垃圾回收算法和配置。常见的垃圾回收算法包括标记-清除（Mark and Sweep）、复制（Copying）、标记-整理（Mark and Compact）等，它们各自有不同的优缺点，适用于不同的场景和需求。</div><div>开发者通常无需干预垃圾回收过程，因为JVM会自动在合适的时机触发垃圾回收。然而，开发者可以通过设置JVM的垃圾回收参数，如堆大小、回收器类型、回收频率等，来优化垃圾回收的性能和内存利用效率。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "5f90c78c-6db2-424f-836e-235cc9dc61e4"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">分代回收机制</span></p>",
                            "note": "<div>分代回收机制是垃圾回收的一种常见策略，用于提高垃圾回收的效率。它基于一个观察，即不同对象的生命周期往往具有不同的特点，因此可以根据对象的年龄将堆内存划分为不同的代（Generation），并针对不同代采用不同的回收策略。</div><div>在典型的分代回收机制中，堆内存一般被划分为以下几个代：</div><ol><li>新生代（Young Generation）：<br>新生代用于存放新创建的对象。它通常被划分为 Eden 区和两个 Survivor 区（一般是 From 区和 To 区）。大多数对象在新生代中很快变为垃圾，因此新生代采用较为频繁的垃圾回收。常用的垃圾回收算法是复制算法（Copying），将存活的对象从 Eden 区复制到 Survivor 区，并清除无用的对象。经过多次回收后，仍然存活的对象会被晋升到老年代。</li><li>老年代（Old Generation）：<br>老年代用于存放生命周期较长的对象。因为老年代中的对象存活时间相对较长，所以垃圾回收发生较少。常用的垃圾回收算法是标记-清除（Mark and Sweep）或标记-整理（Mark and Compact）。标记阶段标记存活对象，清除阶段清除无用的对象，整理阶段将存活对象向一端移动，以提高内存利用效率。</li><li>持久代（Permanent Generation）：<br>持久代用于存放类信息、方法信息等元数据。在 JDK 8 及以前的版本中存在持久代，但在 JDK 8 之后被元空间（Metaspace）取代。元空间不再使用固定大小的内存，而是使用本地内存来存放类和方法的元数据。</li></ol><div>分代回收机制的核心思想是根据对象的生命周期将堆内存划分为不同的代，并针对不同代采用适合的垃圾回收算法和策略。这样可以根据对象的特性进行更精细的回收，提高垃圾回收的效率和性能。分代回收机制被广泛应用于许多现代的垃圾回收器，如Serial、Parallel、CMS、G1等。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "20e2d5d1-09d6-4a17-99cc-419bbc91126e"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">完正的GC流程</span></p>",
                            "note": "<div>完整的垃圾回收（GC）流程可以概括为以下步骤：</div><ol><li>标记（Marking）：<br>垃圾回收器从根对象开始，遍历对象图，标记所有与根对象可达的存活对象。这一步骤使用可达性分析算法，通过对象之间的引用关系来确定对象的可达性。</li><li>清除（Sweeping）：<br>在标记完成后，垃圾回收器会扫描堆内存中的所有对象，清除未被标记的垃圾对象。清除操作会回收垃圾对象所占用的内存空间。</li><li>压缩（Compacting）或整理（Compaction）：<br>在清除操作后，为了优化堆内存的空间利用效率，某些垃圾回收器可能会进行内存压缩或整理操作。内存压缩将存活对象移动到堆内存的一端，以便内存空间的连续分配和更高效的内存访问。</li><li>内存分配（Memory Allocation）：<br>在垃圾回收完成后，JVM会为新的对象分配内存空间。内存分配算法可以是指针碰撞（Bump the Pointer）或空闲列表（Free List）等，用于高效地管理可用的内存空间。</li></ol><div>以上是一个简化的垃圾回收流程，常见的垃圾回收器可能会应用更多的优化和策略。例如，分代回收机制中，会根据对象的生命周期将堆内存划分为不同的代，并根据代的特征采用不同的回收策略。此外，一些垃圾回收器还可能包含并发标记、增量标记、并行回收等阶段，以提高垃圾回收的效率和性能。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "a34eaae3-f08a-4c10-af51-72a60a8762fa"
                        },
                        "children": [
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">标记</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "145c4230-7256-41da-854e-024c178e97b3"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">清楚</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "f4ecb8cf-453f-4672-81d7-c8a5388ef94e"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">压缩</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "e8743a4e-de75-47b0-9c9d-e2aedb59b235"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">内存分配</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "73911918-7c85-453f-b2e4-e4433388a447"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "text": "<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">JVM常用垃圾收集器</span></p>",
                    "richText": true,
                    "expand": true,
                    "isActive": false,
                    "uid": "05dddcf7-97a3-4703-b003-9c90407e0838"
                },
                "children": [
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">G1</span></p>",
                            "note": "<div>G1（Garbage-First）垃圾回收器是Java虚拟机（JVM）中的一种垃圾回收器，于JDK 7u4版本引入，并在JDK 9中成为默认的垃圾回收器。G1垃圾回收器主要针对具有大堆内存的应用程序，旨在提供更可预测的垃圾回收性能和更低的停顿时间。</div><div>G1垃圾回收器的特点和运作方式如下：</div><ol><li>分代回收：G1垃圾回收器仍然使用分代回收机制，将堆内存划分为多个区域。每个区域可以是Eden区、Survivor区或Old区，但不同于传统的分代回收器，G1将堆内存划分为相对均衡的固定大小的区域，而不是固定大小的代。</li><li>并发标记：G1垃圾回收器通过并发标记阶段来标记存活对象。在标记阶段，垃圾回收器会从根对象出发，遍历对象图，并标记存活对象。与传统的停顿标记阶段不同，G1的并发标记与应用程序的执行并发进行，以减少垃圾回收对应用程序的影响。</li><li>区域回收：G1垃圾回收器以区域为基本单位进行垃圾回收。在每次回收时，G1会优先选择垃圾最多的区域进行回收，这也是其名为\"Garbage-First\"的原因。这种方式能够有效地避免全堆回收带来的长时间停顿。</li><li>混合回收：G1垃圾回收器采用了混合回收（Mixed GC）的方式。混合回收在执行垃圾回收时，不仅清理垃圾对象，还会回收一部分可回收的对象。这样可以在较短的时间内回收一部分垃圾，并尽量避免全堆回收的长时间停顿。</li><li>可预测的停顿时间：G1垃圾回收器的目标之一是减少停顿时间。通过将堆内存划分为多个区域，并在垃圾回收时选择垃圾最多的区域进行回收，G1能够更好地控制每次垃圾回收的时间。这样可以在更短的时间内实现可预测的停顿，减少长时间停顿对应用程序的影响。</li></ol><div>G1垃圾回收器在大堆内存场景下表现出色，能够提供更可控的垃圾回收性能和较低的停顿时间。然而，由于不同应用程序的特性和需求不同，选择合适的垃圾回收器需要综合考虑应用程序的内存使用情况、性能需求和硬件环境等因素。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "206905a4-d6f7-4b2a-99c0-f7db0c7f98c6"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">CMS</span></p>",
                            "note": "<div>CMS（Concurrent Mark Sweep）垃圾收集器是Java虚拟机（JVM）中的一种垃圾回收器，旨在减少垃圾回收的停顿时间。CMS是一种并发垃圾回收器，它在应用程序运行的同时进行垃圾回收操作，以减少长时间的停顿。</div><div>CMS垃圾收集器的特点和运作方式如下：</div><ol><li>并发标记：CMS垃圾收集器通过并发标记阶段来标记存活对象。在标记阶段，垃圾收集器会从根对象出发，遍历对象图，并标记存活对象。与传统的停顿标记阶段不同，CMS的并发标记与应用程序的执行并发进行，以减少垃圾回收对应用程序的影响。</li><li>清除阶段：在并发标记完成后，CMS会执行清除阶段。清除阶段会清除未被标记的垃圾对象，释放内存空间。清除操作会导致一小段停顿，但通常较短。</li><li>空间碎片：CMS垃圾收集器采用了一种\"标记-清除\"的算法，会产生内存碎片。由于CMS在并发执行的过程中，应用程序可能会分配和释放对象，导致内存空间的碎片化。这可能会影响到分配大对象或连续内存空间的性能。</li><li>并发回收：与传统的垃圾回收器不同，CMS垃圾收集器的回收阶段是与应用程序并发执行的。这意味着垃圾回收不会阻塞应用程序的运行，但在回收过程中可能会产生一些额外的CPU负载。</li><li>初始标记和重新标记：在CMS的并发标记过程中，为了保证标记的准确性，需要进行初始标记和重新标记两个短暂的停顿阶段。初始标记阶段需要停顿整个应用程序的执行，而重新标记阶段可以与应用程序的执行并发进行。这两个阶段的停顿时间通常较短。</li></ol><div>CMS垃圾收集器适用于对垃圾回收停顿时间要求较高的应用程序，它在减少停顿时间方面表现出色。然而，CMS垃圾收集器也有一些限制，例如可能产生碎片化的内存空间、并发回收可能引入一些额外的CPU负载等。在选择垃圾收集器时，需要根据应用程序的特性和需求综合考虑。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "19ab3a02-f055-434a-8996-0ece1c5601b6"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Serial</span></p>",
                            "note": "<div>在 Java 虚拟机（JVM）中，并行垃圾回收器（Serial Garbage Collector）是一种简单且单线程的垃圾回收器，主要用于开发和调试环境。它的主要特点是简单、高效，并且适用于较小的应用程序。</div><div>Serial 垃圾回收器的工作方式如下：</div><ol><li>停顿所有应用线程：在进行垃圾回收时，Serial 垃圾回收器会暂停所有的应用线程，以便于进行垃圾回收操作。</li><li>标记（Marking）：Serial 垃圾回收器从根对象开始，遍历对象图，标记所有与根对象可达的存活对象。这一步骤使用可达性分析算法，通过对象之间的引用关系来确定对象的可达性。标记过程是单线程执行的。</li><li>清除（Sweeping）：在标记完成后，Serial 垃圾回收器会扫描堆内存中的所有对象，清除未被标记的垃圾对象。清除操作会回收垃圾对象所占用的内存空间。清除也是单线程执行的。</li><li>压缩（Compacting）或整理（Compaction）（可选）：Serial 垃圾回收器在清除操作后，可以选择进行内存压缩或整理操作，以优化堆内存的空间利用效率。压缩操作将存活对象移动到堆内存的一端，以便内存空间的连续分配和更高效的内存访问。</li><li>恢复应用线程：在垃圾回收完成后，Serial 垃圾回收器会恢复所有被暂停的应用线程的执行，使程序继续运行。</li></ol><div>Serial 垃圾回收器的主要优点是简单高效，适用于较小的应用程序和资源受限的环境。然而，它是单线程的垃圾回收器，无法充分利用多核处理器的性能，并且会导致较长的停顿时间。因此，在大型应用程序和需要较低停顿时间的场景下，通常会选择其他更高级的并行或并发垃圾回收器。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "46e7848e-efc9-48d4-a58f-79ab33e48077"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Parallel</span></p>",
                            "note": "<div>Parallel 垃圾回收器（Parallel Garbage Collector）是 Java 虚拟机（JVM）中的一种并行垃圾回收器，旨在通过利用多个线程并行执行垃圾回收操作来提高垃圾回收的效率。它适用于具有多个处理器和较大堆内存的应用程序。</div><div>Parallel 垃圾回收器的工作方式如下：</div><ol><li>并行标记（Parallel Marking）：在进行垃圾回收时，Parallel 垃圾回收器会使用多个线程并行执行标记操作。每个线程负责标记一部分对象，从根对象开始遍历对象图，并标记存活对象。并行标记可以加快标记过程的速度。</li><li>并行清除（Parallel Sweeping）：在标记完成后，Parallel 垃圾回收器会使用多个线程并行执行清除操作。每个线程负责清除一部分未被标记的垃圾对象，释放内存空间。并行清除可以提高清除过程的效率。</li><li>可选的压缩（Optional Compaction）：在清除操作后，Parallel 垃圾回收器可以选择进行内存压缩操作，以优化堆内存的空间利用效率。压缩操作将存活对象移动到堆内存的一端，以便内存空间的连续分配和更高效的内存访问。</li><li>恢复应用线程：在垃圾回收完成后，Parallel 垃圾回收器会恢复所有被暂停的应用线程的执行，使程序继续运行。</li></ol><div>Parallel 垃圾回收器的主要优点是并行执行垃圾回收操作，充分利用多个处理器的性能，从而加快垃圾回收的速度。它适用于大型应用程序和需要高吞吐量的场景，但可能会导致较长的停顿时间。因此，在需要更低停顿时间的交互式应用程序中，可能需要考虑其他并发垃圾回收器，如 G1（Garbage-First）垃圾回收器。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "93fe8a38-e641-44a4-b151-b5d3ed5030ae"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "text": "<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Spring IoC</span></p>",
                    "richText": true,
                    "expand": true,
                    "isActive": false,
                    "uid": "8f3086f6-8d1d-40f6-bc11-4ded89bcd0a7"
                },
                "children": [
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">什么是IOC</span></p>",
                            "note": "<div>在Spring框架中，IOC（Inversion of Control，控制反转）是一种设计原则和实现机制，用于实现对象之间的解耦和依赖关系的管理。在IOC中，对象的创建、组装和管理不再由应用程序显式地控制，而是由容器来负责。</div><div>IOC 的核心思想是将对象的创建和依赖关系的管理交给容器来完成，应用程序只需要声明对象之间的关系，而不需要关心对象的创建和销毁过程。这样可以降低组件之间的耦合度，提高代码的可维护性和可测试性。</div><div>在Spring框架中，IOC的实现主要依靠依赖注入（Dependency Injection，DI）机制。依赖注入通过容器将对象所依赖的其他对象注入到它们之中，使得对象之间的依赖关系得以自动建立和管理。</div><div>通过IOC和依赖注入，开发人员只需要定义对象之间的依赖关系，而不需要直接创建和管理这些对象。Spring容器负责创建和管理对象，并将依赖关系注入到相应的对象中，从而实现了对象之间的解耦和灵活的组装。</div><div>IOC的优点包括：</div><ol><li>降低组件之间的耦合度，提高代码的可维护性和可测试性。</li><li>提供了更好的可扩展性，可以方便地替换、增加或修改组件。</li><li>提升了代码的可读性和理解性，对象之间的依赖关系变得清晰可见。</li></ol><div>总之，IOC（控制反转）是Spring框架的核心概念之一，通过将对象的创建和依赖关系的管理交给容器来完成，实现对象之间的解耦和依赖关系的自动管理。IOC主要依赖于依赖注入（DI）机制，通过容器将对象所依赖的其他对象注入到它们之中。这样可以提高代码的可维护性、可测试性，并降低组件之间的耦合度。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "815e5d94-97dd-44d0-9f9e-3210f340e042"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">BeanFactory与ApplicationContext</span></p>",
                            "note": "<div>在Spring框架中，BeanFactory和ApplicationContext都是用于管理和提供对象（Bean）的容器。</div><div>BeanFactory是Spring框架的最基本的容器接口，提供了对Bean的创建、获取、销毁等基本操作的支持。它是一个低级别的容器，延迟加载（Lazy-loading）方式创建Bean，即在需要使用Bean时才进行创建。BeanFactory的实现类有XmlBeanFactory、DefaultListableBeanFactory等。</div><div>ApplicationContext是BeanFactory的一个子接口，它在BeanFactory的基础上提供了更多的功能和特性。ApplicationContext是一个高级别的容器，它在启动时就立即实例化所有的单例Bean，并且提供了更多的企业级特性，如事件发布、AOP集成、资源加载、Bean生命周期管理等。ApplicationContext的实现类有ClassPathXmlApplicationContext、FileSystemXmlApplicationContext等。</div><div>下面是一些BeanFactory和ApplicationContext之间的主要区别：</div><ol><li>延迟加载 vs. 提前加载：BeanFactory采用延迟加载机制，即在需要使用Bean时才进行创建，而ApplicationContext在启动时就会实例化所有的单例Bean。</li><li>配置文件加载方式：BeanFactory通常使用XmlBeanDefinitionReader来加载XML配置文件，而ApplicationContext可以支持多种配置文件的加载方式，包括XML、注解、JavaConfig等。</li><li>功能和特性：ApplicationContext相比BeanFactory提供了更多的企业级特性，如事件发布、AOP集成、资源加载、Bean生命周期管理等。</li><li>配置元数据的缓存：ApplicationContext在加载配置元数据时通常会进行缓存，以提高性能，而BeanFactory不会进行缓存。</li><li>扩展点支持：ApplicationContext提供了一些扩展点，如BeanPostProcessor、BeanFactoryPostProcessor等，可以对Bean的创建过程进行拦截和修改。</li></ol><div>综上所述，BeanFactory是Spring的基本容器接口，提供了基本的Bean管理功能，采用延迟加载机制；而ApplicationContext是BeanFactory的子接口，提供了更多的特性和功能，采用提前加载机制，适用于大多数企业级应用场景。在实际开发中，通常使用ApplicationContext来管理和提供Bean。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "a9836d6d-6f93-4584-89fd-f2f74a8db027"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Bean的作用域</span></p>",
                            "note": "<div>在Spring框架中，Bean的作用域定义了Bean实例的生命周期和可见范围。Spring提供了多种作用域，可以根据需求选择适合的作用域。以下是Spring框架中常用的Bean作用域：</div><ol><li>Singleton（默认）：在整个应用程序中，只创建一个Bean实例，并且所有对该Bean的请求都返回同一个实例。这是Spring默认的作用域。</li><li>Prototype：每次请求Bean时都会创建一个新的实例，即每次通过容器获取Bean都会得到一个新的对象。</li><li>Request：每个HTTP请求都会创建一个新的Bean实例，该Bean实例仅在当前HTTP请求范围内有效。不同的HTTP请求将获得不同的Bean实例。</li><li>Session：每个HTTP会话（Session）都会创建一个新的Bean实例，该Bean实例仅在当前HTTP会话范围内有效。不同的HTTP会话将获得不同的Bean实例。</li><li>Global Session（仅适用于Web应用）：每个全局HTTP会话（Global Session）都会创建一个新的Bean实例，该Bean实例仅在全局HTTP会话范围内有效。在基于portlet的Web应用中使用。</li><li>Application（仅适用于Web应用）：在整个Web应用中，只创建一个Bean实例，并且在整个应用的生命周期内都有效。</li></ol><div>除了以上常见的作用域，Spring还提供了其他一些特殊的作用域，如WebSocket、Custom等，可以根据具体需求自定义作用域。</div><div>选择适当的Bean作用域非常重要，它决定了Bean实例的生命周期和可见范围。默认的Singleton作用域适用于大多数情况，但在某些情况下，如需要每次请求都获得一个新的实例或在不同的会话中使用不同的实例时，可以选择其他作用域来满足需求。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "1b2d98ab-d033-4328-ae96-783643e7bcdc"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Bean的生命周期</span></p>",
                            "note": "<div>在Spring框架中，Bean的生命周期可以分为以下几个阶段：</div><ol><li>实例化（Instantiation）：在这个阶段，Spring容器会根据Bean的定义和配置信息创建Bean的实例。实例化的方式可以是通过构造函数创建对象，或者通过工厂方法创建对象。</li><li>属性赋值（Population of Properties）：在这个阶段，Spring容器会将配置文件中定义的属性值或引用注入到Bean实例中。这可以通过属性注入、构造函数注入或者方法注入来完成。</li><li>初始化（Initialization）：在这个阶段，Spring容器会调用Bean的初始化回调方法。可以通过实现InitializingBean接口的afterPropertiesSet()方法或者在配置文件中指定init-method来定义初始化回调方法。在这个阶段，可以进行一些初始化操作，如数据加载、资源分配等。</li><li>使用（In Use）：在这个阶段，Bean实例已经完成初始化，并可以被应用程序使用。应用程序可以调用Bean的方法来执行相应的业务逻辑。</li><li>销毁（Destruction）：在容器关闭或者销毁Bean的时候，会触发Bean的销毁阶段。可以通过实现DisposableBean接口的destroy()方法或者在配置文件中指定destroy-method来定义销毁回调方法。在这个阶段，可以进行一些清理资源、释放连接等操作。</li></ol><div>需要注意的是，对于单例作用域的Bean，默认情况下，Spring容器会在容器关闭时自动销毁这些Bean实例。对于其他作用域的Bean，如原型（Prototype）作用域，Spring容器不会负责销毁，需要手动进行销毁。</div><div>总结来说，Bean的生命周期包括实例化、属性赋值、初始化、使用和销毁等阶段。通过合适的回调方法和配置，可以在每个阶段对Bean进行自定义操作，满足应用程序的需求。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "ee8c8003-7512-4341-8b4e-e0dbdba5071d"
                        },
                        "children": [
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">实例化</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "ccfe0e3f-afed-4f10-a124-d4cd5121ae58"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">属性赋值</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "c1c2a296-121e-4dad-94a4-b2fd1a0b569a"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">初始化</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "f25a091d-8fc3-4d3d-bd73-e8ad36735656"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">使用</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "49509727-3819-4810-bbb1-b442c300c321"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">销毁</span></p>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "b69a1cf6-6740-4fb5-a149-aa5b27a0741f"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Spring是怎么解决循环依赖的</span></p>",
                            "note": "<div>Spring通过使用三级缓存解决循环依赖问题。当两个或多个Bean之间存在循环依赖时，Spring使用三级缓存来跟踪和管理这些Bean的创建过程。</div><ol><li>Singleton Objects Cache（一级缓存）：在创建Bean的过程中，Spring会将正在创建的Bean放入一级缓存中。这样，当后续的Bean创建过程中需要引用该Bean时，Spring可以直接从缓存中获取已经创建的实例。</li><li>Early-Stage Objects Cache（二级缓存）：如果一级缓存中没有需要的Bean实例，Spring会将正在创建的Bean放入二级缓存中。在此阶段，Spring将创建的Bean实例进行填充，但尚未完全初始化。这样，当后续的Bean创建过程中需要引用该Bean时，Spring可以从二级缓存中获取实例，但仍然不是完全初始化的实例。</li><li>Singleton Factories Cache（三级缓存）：如果一级和二级缓存都无法满足依赖关系，Spring会将正在创建的Bean放入三级缓存中。在此阶段，Spring会创建一个Bean的提供者对象（ObjectFactory），它负责返回完全初始化的Bean实例。当后续的Bean创建过程中需要引用该Bean时，Spring会从三级缓存中获取Bean的提供者对象，并通过提供者对象获取完全初始化的实例。</li></ol><div>通过使用这三级缓存机制，Spring可以解决循环依赖问题。当循环依赖的Bean创建完毕后，Spring会将相应的Bean实例放入一级缓存中，以供后续的Bean创建引用。这样，即使存在循环依赖，Spring也能够正确地创建和管理Bean的实例。</div><div><br><br>除了三级缓存机制，Spring还提供了另外两种方式来解决循环依赖问题：</div><ol><li>提前暴露（Early Bean Post-Processors）：Spring框架允许在Bean实例化的过程中使用Bean后置处理器（BeanPostProcessor）对Bean进行修改。通过实现BeanPostProcessor接口并注册为Bean后置处理器，可以在Bean实例化之后但在初始化之前拦截Bean的创建过程。在拦截的过程中，可以提前暴露尚未初始化的Bean实例，以解决循环依赖问题。</li><li>构造函数注入：使用构造函数注入可以避免循环依赖问题的发生。通过将依赖关系通过构造函数的方式注入，可以确保在Bean实例化时就满足依赖关系，而不需要等待属性的注入或初始化阶段。这样可以避免循环依赖的产生。</li></ol><div>这两种方式都可以用来解决循环依赖问题，但需要注意以下事项：</div><ul><li>提前暴露方式可能会导致Bean实例在完全初始化之前就被暴露出去，可能会引入一些安全性和一致性的问题。因此，建议谨慎使用，并确保在使用过程中不会产生潜在的问题。</li><li>构造函数注入方式可以有效地避免循环依赖问题，但需要注意避免构造函数参数过多的情况，以保持代码的可读性和可维护性。</li></ul><div>综上所述，除了三级缓存机制外，Spring还提供了提前暴露和构造函数注入两种方式来解决循环依赖问题。根据具体的应用场景和需求，可以选择适合的方式来解决循环依赖。</div><div><br><br><br></div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "5ee9e36c-8a9f-4f9c-919a-39b1dd6872d6"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "text": "<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Spring AOP</span></p>",
                    "richText": true,
                    "expand": true,
                    "isActive": false,
                    "uid": "bbc156f5-35c8-44bd-b61a-7afd73dfb240"
                },
                "children": [
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">AOP的概念</span></p>",
                            "note": "<div>Spring AOP（Aspect-Oriented Programming）是Spring框架的一个关键特性，用于支持面向切面编程的开发方式。AOP是一种编程范式，旨在通过将横切关注点（Cross-cutting Concerns）与核心业务逻辑分离，以提高代码的模块化性、可维护性和可重用性。</div><div>在传统的面向对象编程中，业务逻辑分散在各个对象的方法中，而与之相关的横切关注点（如日志记录、事务管理、安全性检查等）则分散在多个对象或方法中。这样的分散导致了代码的冗余和复杂性。</div><div>Spring AOP通过引入切面（Aspect）的概念，将横切关注点从核心业务逻辑中剥离出来，并以模块化的方式进行管理。切面是一个包含通知（Advice）和切点（Pointcut）的结构，其中通知定义了在何时和如何执行横切逻辑，而切点则定义了在哪些地方应用这些通知。</div><div>Spring AOP采用代理模式来实现切面的功能。在运行时，Spring会为目标对象动态生成一个代理对象，该代理对象将核心业务逻辑和横切逻辑进行组合。当调用目标对象的方法时，代理对象会根据配置的切点和通知，决定是否在方法执行前、后或异常发生时插入横切逻辑的执行。</div><div>Spring AOP提供了以下几种通知类型：</div><ol><li>前置通知（Before Advice）：在目标方法执行之前执行的通知。</li><li>后置通知（After Advice）：在目标方法执行之后（无论是否发生异常）执行的通知。</li><li>返回通知（After Returning Advice）：在目标方法成功执行并返回结果后执行的通知。</li><li>异常通知（After Throwing Advice）：在目标方法抛出异常后执行的通知。</li><li>环绕通知（Around Advice）：将横切逻辑包裹在目标方法的前后执行，可以控制目标方法的执行过程。</li></ol><div>通过使用Spring AOP，开发者可以将横切关注点与核心业务逻辑解耦，提高代码的模块化性和可维护性。可以通过配置文件或注解的方式来定义切面和通知，并将其应用到相应的目标对象上。</div><div>总结来说，Spring AOP是Spring框架中的一个重要特性，用于支持面向切面编程。它通过引入切面、代理模式和各种通知类型，实现了横切关注点的分离和动态调用，提供了一种灵活且可重用的方式来处理横切逻辑。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "555367e1-0755-4318-a878-954fd83c10cb"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">AOP的术语</span></p>",
                            "note": "<div>在Spring AOP中，有一些常用的术语和概念，包括：</div><ol><li>切面（Aspect）：切面是一个模块化的单元，它包含着与横切关注点相关的通知和切点。通常，一个切面会横跨多个类和对象，用于封装横切关注点的行为。</li><li>通知（Advice）：通知定义了在何时和如何执行横切逻辑。在Spring AOP中，有五种类型的通知：前置通知、后置通知、返回通知、异常通知和环绕通知。</li><li>切点（Pointcut）：切点定义了在哪些地方应用通知。它是一个表达式，用于匹配目标对象中的方法。切点表达式可以使用通配符、正则表达式或者自定义规则来描述要匹配的方法。</li><li>连接点（Join Point）：连接点是在应用程序执行过程中能够插入切面的点。在Spring AOP中，连接点通常表示方法的执行，但也可以是其他事件，如异常抛出或字段访问。</li><li>切面顺序（Aspect Order）：如果应用中存在多个切面，则可以通过指定切面的顺序来控制它们的执行顺序。切面顺序可以通过实现Ordered接口或使用@Order注解来指定。</li><li>引入（Introduction）：引入是一种将额外的方法或属性添加到现有的类中的方式。通过引入，可以在不修改原始类代码的情况下，为目标对象添加新的行为。</li><li>织入（Weaving）：织入是将切面应用到目标对象中的过程。在织入过程中，切面的通知被插入到目标对象的连接点上，以实现横切逻辑的执行。</li><li>目标对象（Target Object）：目标对象是被织入切面的原始对象，它包含着核心业务逻辑。</li><li>代理对象（Proxy Object）：代理对象是在运行时生成的，用于包装目标对象并应用切面的对象。当调用代理对象的方法时，切面的通知会被触发。</li></ol><div>这些术语和概念是理解和使用Spring AOP的基础，它们共同构成了AOP编程模型的核心。通过合理应用这些术语和概念，可以更好地实现横切关注点的管理和控制。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "3dbe7345-f262-4b56-9a0a-049a8d7f95ac"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Spring AOP的实现原理</span></p>",
                            "note": "<div>Spring AOP的实现原理主要基于动态代理技术。在运行时，Spring会为目标对象生成一个代理对象，该代理对象包含了切面的横切逻辑，并在调用目标对象的方法时触发执行。</div><div>Spring AOP提供了两种类型的代理：JDK动态代理和CGLIB代理。</div><ol><li>JDK动态代理：当目标对象实现了至少一个接口时，Spring会使用JDK动态代理来创建代理对象。JDK动态代理基于Java的标准反射机制，通过创建实现目标接口的代理类，并实现InvocationHandler接口来处理方法调用。在运行时，当调用代理对象的方法时，实际上是通过InvocationHandler的invoke()方法拦截并处理方法调用，包括执行切面的通知。</li><li>CGLIB代理：当目标对象没有实现任何接口时，Spring会使用CGLIB（Code Generation Library）来创建代理对象。CGLIB是一个强大的代码生成库，它通过继承目标对象的子类来创建代理。在运行时，CGLIB会生成一个继承自目标对象的子类，并重写目标对象的方法，在方法的前后插入切面的通知。</li></ol><div>Spring AOP的实现流程如下：</div><ol><li>定义切面：开发者通过配置文件或注解方式定义切面，包括切点和通知类型。</li><li>创建代理对象：当应用程序加载目标对象时，Spring会检测目标对象是否需要代理。如果需要代理，则根据目标对象是否实现接口来选择生成JDK动态代理还是CGLIB代理。</li><li>拦截方法调用：当调用代理对象的方法时，代理对象会拦截方法调用并委托给相应的InvocationHandler或CGLIB子类。这些拦截器会根据配置的切点，决定是否执行切面的通知。</li><li>执行通知：根据切点的匹配结果，代理对象会在方法的前后或异常发生时触发执行相应的通知。通知包括前置通知、后置通知、返回通知、异常通知和环绕通知。</li></ol><div>通过动态代理技术，Spring AOP能够在运行时动态地将切面的横切逻辑织入目标对象的方法调用中。这种方式使得开发者可以将横切关注点与核心业务逻辑解耦，提高代码的模块化性和可维护性。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "b6a494af-bb0d-45c9-85d6-72d303843f60"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">JDK动态代理和CGLIB的区别</span></p>",
                            "note": "<div>JDK动态代理和CGLIB代理是Spring AOP中常用的两种代理方式，它们在实现原理和适用场景上有一些区别。</div><ol><li>基于接口和继承的差异：<ul><li>JDK动态代理要求目标对象实现至少一个接口，代理对象将实现目标对象接口，并委托给InvocationHandler处理方法调用。因此，它只能代理接口中定义的方法。</li><li>CGLIB代理则通过继承目标对象的子类来创建代理对象，无需目标对象实现接口。CGLIB代理可以代理目标对象的所有方法，包括final方法。</li></ul></li><li>创建代理对象的方式：<ul><li>JDK动态代理使用Java标准的反射机制，通过Proxy类和InvocationHandler接口创建代理对象。</li><li>CGLIB代理使用CGLIB库，通过继承目标对象的子类来创建代理对象。</li></ul></li><li>性能的差异：<ul><li>JDK动态代理使用Java标准的反射机制，相对于CGLIB代理，它的性能较高。但当目标对象没有实现接口时，无法使用JDK动态代理。</li><li>CGLIB代理通过继承目标对象的子类，对方法进行重写，因此在方法调用时不涉及反射操作，相对于JDK动态代理，它的性能较低。但它可以代理没有实现接口的目标对象。</li></ul></li><li>适用场景：<ul><li>JDK动态代理适用于代理接口实现的类，常用于对业务接口的代理，如对Service层的方法进行事务管理。</li><li>CGLIB代理适用于代理没有实现接口的类，常用于对普通类的代理，如对DAO层的方法进行性能监控或缓存处理。</li></ul></li></ol><div>总结来说，JDK动态代理适用于代理接口实现的类，性能较高；而CGLIB代理适用于代理没有实现接口的类，性能较低。在选择代理方式时，需要根据具体的应用场景和需求来确定使用哪种代理方式。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "a1078ee2-a59d-4930-9f57-b8e34309cd8b"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "text": "<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">SpringMVC</span></p>",
                    "richText": true,
                    "expand": true,
                    "isActive": false,
                    "uid": "b9503af3-2e55-4f57-bc95-99010a6d3f3b"
                },
                "children": [
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">什么是MVC</span></p>",
                            "note": "<div>在Spring框架中，MVC指的是基于Spring MVC（Model-View-Controller）的Web应用程序开发模式。Spring MVC是Spring框架提供的一个模块，用于构建灵活、可扩展和可维护的Web应用程序。</div><div>在Spring MVC中，MVC的核心概念与传统的MVC模式相似，但有一些特定的实现细节和功能扩展。</div><ol><li>模型（Model）：<ul><li>模型代表应用程序的数据和业务逻辑。</li><li>在Spring MVC中，模型可以是普通的Java对象（POJO）或由Spring的依赖注入容器管理的Bean。</li><li>模型对象包含应用程序的数据，并提供对数据的访问和操作方法。</li></ul></li><li>视图（View）：<ul><li>视图负责呈现模型数据给用户，并处理用户界面的展示逻辑。</li><li>在Spring MVC中，视图通常是模板引擎（如Thymeleaf、Freemarker、JSP）生成的动态页面，或者是前端框架（如React、Angular）生成的前端组件。</li><li>视图将模型的数据进行渲染，并生成最终的用户界面。</li></ul></li><li>控制器（Controller）：<ul><li>控制器接收用户的请求，并根据请求调用相应的业务逻辑和模型处理。</li><li>在Spring MVC中，控制器是由开发者编写的Java类，使用@Controller注解进行标记。</li><li>控制器根据请求的URL和参数，调用相应的服务、处理业务逻辑，并将处理结果封装到模型中，然后将模型传递给视图进行展示。</li></ul></li></ol><div>Spring MVC提供了许多功能和特性，包括请求映射、数据绑定、表单处理、拦截器、异常处理、国际化支持等。它还具有灵活的配置选项，可以通过XML配置文件或基于注解的方式进行配置。</div><div>通过使用Spring MVC，开发者可以以一种结构化和模块化的方式开发Web应用程序，提高开发效率和代码的可维护性。Spring MVC也与其他Spring框架模块（如Spring Boot）紧密集成，为构建现代化的Web应用程序提供了便利。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "ebc4110f-a021-4db0-a020-8c79922f291e"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">执行流程</span></p>",
                            "note": "<div>Spring MVC的执行流程可以简要概括为以下几个步骤：</div><ol><li>客户端发送请求：<ul><li>客户端（通常是浏览器）向服务器发送HTTP请求，请求的URL匹配到Spring MVC的DispatcherServlet。</li></ul></li><li>DispatcherServlet接收请求：<ul><li>DispatcherServlet是Spring MVC的核心控制器，它接收到所有的请求，并根据配置进行处理。</li><li>DispatcherServlet根据请求的URL查找并调用相应的处理器映射器（Handler Mapping）。</li></ul></li><li>处理器映射器解析请求：<ul><li>处理器映射器根据请求的URL找到对应的处理器（控制器）。</li><li>处理器映射器将请求映射到一个合适的处理器对象，即控制器。</li></ul></li><li>控制器处理请求：<ul><li>控制器（通常是一个带有@Controller注解的Java类）接收到请求后，根据业务逻辑进行处理。</li><li>控制器可以访问模型（Model）和服务层（Service）来处理业务逻辑，并将结果封装到模型中。</li></ul></li><li>控制器返回视图名称：<ul><li>控制器处理完请求后，返回一个逻辑视图名（View Name）。</li><li>逻辑视图名是一个标识符，用于标识要返回的具体视图。</li></ul></li><li>视图解析器解析视图：<ul><li>视图解析器根据逻辑视图名解析出真正的视图对象。</li><li>视图解析器根据配置规则，将逻辑视图名映射到具体的视图模板引擎（如JSP、Thymeleaf）或前端框架（如React、Angular）。</li></ul></li><li>视图渲染：<ul><li>视图对象将模型数据填充到视图模板中，生成最终的HTML或其他响应内容。</li><li>视图渲染完成后，生成响应内容返回给客户端。</li></ul></li><li>客户端接收响应：<ul><li>客户端（浏览器）接收到服务器返回的响应，根据响应内容进行展示。</li></ul></li></ol><div>在整个流程中，DispatcherServlet充当了中央调度器的角色，负责协调各个组件的工作。处理器映射器（Handler Mapping）用于确定请求应该由哪个控制器处理，而视图解析器（View Resolver）则负责将逻辑视图名解析为具体的视图对象。控制器处理请求时可以访问模型（Model）来获取或修改数据，并将结果传递给视图进行渲染。</div><div>通过这样的执行流程，Spring MVC实现了请求的分发和处理，将请求与处理逻辑解耦，提供了一种结构化和可扩展的方式来开发Web应用程序。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "680072e2-3c75-4f42-8724-b0d724e030b1"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">常用注解</span></p>",
                            "note": "<div>在Spring MVC中，有一些常用的注解用于标记和配置控制器、请求处理方法、请求参数绑定等。以下是一些常用的Spring MVC注解：</div><ol><li>@Controller：用于标记一个类作为控制器组件，处理用户请求。</li><li>@RequestMapping：用于将请求URL映射到控制器处理方法。</li><li>@GetMapping：用于将HTTP GET请求映射到控制器处理方法。</li><li>@PostMapping：用于将HTTP POST请求映射到控制器处理方法。</li><li>@PutMapping：用于将HTTP PUT请求映射到控制器处理方法。</li><li>@DeleteMapping：用于将HTTP DELETE请求映射到控制器处理方法。</li><li>@PathVariable：用于将URL中的变量部分映射到方法参数。</li><li>@RequestParam：用于将请求参数映射到方法参数。</li><li>@RequestBody：用于将请求体中的数据映射到方法参数。</li><li>@ResponseBody：用于将方法返回值直接作为响应体返回给客户端。</li><li>@ModelAttribute：用于将请求参数绑定到方法参数或模型对象。</li><li>@Valid：用于开启参数验证，配合验证框架（如Hibernate Validator）使用。</li><li>@SessionAttributes：用于指定模型属性存储在会话中，以便多个请求之间共享。</li><li>@InitBinder：用于在控制器中自定义数据绑定和格式化规则。</li><li>@ExceptionHandler：用于处理控制器中的异常。</li></ol><div>这些注解可以根据具体需求和场景来灵活使用，以实现请求的映射、参数绑定、验证、异常处理等功能。它们使得开发者能够通过注解方式简化配置，并更加便捷地开发和管理Spring MVC应用程序。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "a9fb47c6-b68f-432a-8c14-59c6abd0a4a5"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">拦截器</span></p>",
                            "note": "<div>在Spring MVC中，拦截器（Interceptor）是一种强大的机制，用于在请求处理的各个阶段插入自定义的处理逻辑。拦截器可以对请求进行预处理、后处理和响应处理，并允许开发者在请求处理的各个阶段进行自定义操作。</div><div>以下是使用拦截器的步骤和常见用法：</div><ol><li>创建拦截器类：<ul><li>创建一个实现了HandlerInterceptor接口的拦截器类。</li><li>HandlerInterceptor接口定义了三个方法：preHandle、postHandle和afterCompletion，用于在请求处理的不同阶段执行自定义逻辑。</li></ul></li><li>配置拦截器：<ul><li>在Spring MVC的配置文件（如XML配置文件或Java配置类）中，通过拦截器配置将拦截器添加到拦截器链中。</li><li>可以指定拦截器的拦截路径，即希望拦截哪些请求的URL。</li></ul></li><li>编写拦截器逻辑：<ul><li>在拦截器的preHandle方法中，可以进行一些预处理操作，如鉴权、日志记录、请求参数验证等。</li><li>在拦截器的postHandle方法中，可以对请求的处理结果进行后处理，如添加额外的模型数据、修改视图等。</li><li>在拦截器的afterCompletion方法中，可以进行一些清理操作，如资源释放、日志记录等。</li></ul></li><li>通过拦截器链执行拦截器：<ul><li>当请求到达时，拦截器链会按照配置的顺序依次调用每个拦截器的preHandle方法。</li><li>如果preHandle方法返回true，则继续执行后续的拦截器和处理器（控制器）。</li><li>在处理器执行完成后，拦截器链会按照相反的顺序调用每个拦截器的postHandle方法。</li><li>最后，拦截器链会再次按照相反的顺序调用每个拦截器的afterCompletion方法。</li></ul></li></ol><div>拦截器可用于各种场景，如身份验证、日志记录、性能监控、跨域处理等。通过拦截器，可以在请求的不同阶段进行自定义的处理和干预，以实现更精细的控制和功能扩展。</div><div>在Spring MVC中，可以使用XML配置文件或Java配置类来配置拦截器，具体的配置方式取决于使用的Spring版本和配置风格。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "f98b7908-1f66-420b-9777-b6db84d6d742"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">SpringBoot启动流程</span></p>",
                            "note": "<div>Spring Boot的启动流程可以简要概括为以下几个步骤：</div><ol><li>加载配置和初始化应用上下文：<ul><li>Spring Boot首先加载应用的配置文件（如application.properties或application.yml）。</li><li>根据配置文件的内容，初始化并创建应用上下文（Application Context）。</li></ul></li><li>扫描和加载组件：<ul><li>Spring Boot会扫描应用的类路径（classpath）以及自定义的配置包，寻找带有特定注解（如@Component、@Controller、@Service等）的类。</li><li>找到这些带有注解的类后，Spring Boot将其实例化并注册为组件。</li></ul></li><li>执行自动配置：<ul><li>Spring Boot基于约定大于配置的原则，提供了许多自动配置类（AutoConfiguration）。</li><li>自动配置类通过条件注解（如@ConditionalOnClass、@ConditionalOnProperty等）来判断是否需要配置某些组件或功能。</li><li>根据应用的依赖和配置，Spring Boot会自动启用适当的自动配置类，完成相应的组件初始化和配置。</li></ul></li><li>启动应用：<ul><li>在完成组件的加载和配置后，Spring Boot会启动应用。</li><li>它会创建并启动内嵌的Servlet容器（如Tomcat、Jetty等），并将应用部署到其中。</li><li>启动后，应用开始监听指定的端口，等待客户端请求的到来。</li></ul></li></ol>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "0676a186-b860-4de4-a481-8f9cdd600b1f"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">@Transaction</span></p>",
                            "note": "<div>在Spring框架中，@Transaction注解用于声明事务的边界。它可以应用于方法或类级别，并指示方法或类应在事务管理下执行。@Transaction注解的工作原理如下：</div><ol><li>事务管理器配置：<br>首先，需要在Spring配置文件中配置一个事务管理器（如DataSourceTransactionManager），用于管理事务的创建、提交和回滚操作。事务管理器需要与数据源（如数据库）进行关联。</li><li>事务切面：<br>使用Spring AOP（面向切面编程）的机制，Spring会在运行时生成代理对象来拦截带有@Transaction注解的方法或类。这个代理对象将负责管理事务的开启、提交和回滚。</li><li>事务边界检测：<br>当执行带有@Transaction注解的方法时，代理对象会检测当前是否存在一个事务。如果不存在事务，则会创建一个新的事务；如果已存在事务，则会加入到当前事务中。</li><li>事务执行：<br>在事务边界内，代理对象会执行目标方法的逻辑。如果方法成功执行完成，代理对象将提交事务。如果方法抛出异常，代理对象将回滚事务。</li><li>事务传播属性：<br>@Transaction注解还支持事务的传播属性，用于定义事务方法如何与已存在的事务进行交互。例如，可以指定事务方法应该使用已存在的事务，或者创建一个新的事务。</li></ol><div>通过以上机制，@Transaction注解实现了声明式的事务管理。开发人员只需通过简单的注解，而无需手动编写事务管理的代码。这样可以提高开发效率，并使事务管理与业务逻辑相分离，提供了更好的可维护性和灵活性。</div>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "c40a3833-9d2c-482b-bcad-d48f8f4d6be0"
                        },
                        "children": [
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">事务传播方式</span></p>",
                                    "note": "<div>Spring框架提供了多种事务传播方式（Transaction Propagation）来定义事务方法与已存在的事务之间的交互方式。以下是常见的事务传播方式：</div><ol><li>REQUIRED：<br>如果当前存在事务，则方法将在该事务中执行；如果没有事务，则新建一个事务。这是最常用的传播方式。</li><li>SUPPORTS：<br>如果当前存在事务，则方法将在该事务中执行；如果没有事务，则以非事务方式执行。</li><li>MANDATORY：<br>方法必须在一个已存在的事务中执行，否则将抛出异常。</li><li>REQUIRES_NEW：<br>无论当前是否存在事务，方法将总是在新的事务中执行。如果当前存在事务，会将其挂起。</li><li>NOT_SUPPORTED：<br>方法将以非事务方式执行。如果当前存在事务，会将其挂起。</li><li>NEVER：<br>方法必须以非事务方式执行。如果当前存在事务，则抛出异常。</li><li>NESTED：<br>如果当前存在事务，则在嵌套事务中执行。如果没有事务，则行为与REQUIRED传播方式类似。嵌套事务可以独立地进行提交或回滚，而不影响外部事务的提交或回滚。</li></ol><div>这些事务传播方式可以通过在方法上使用@Transactional(propagation = Propagation.XXX)来指定，其中Propagation.XXX表示相应的事务传播方式。根据具体的业务需求，选择适当的事务传播方式可以确保事务行为的一致性和正确性。</div><div>需要注意的是，事务传播方式仅适用于嵌套在事务中的方法调用，而不适用于非事务方法调用。</div>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "9248e046-4eca-4da1-9f37-85b344c12638"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">REQUIRED(需要)</span></p>",
                                            "richText": true,
                                            "expand": true,
                                            "isActive": false,
                                            "uid": "5ead85be-a948-47bf-823a-782dcfbc916e"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">SUPPORTS</span></p>",
                                            "richText": true,
                                            "expand": true,
                                            "isActive": false,
                                            "uid": "5a05bc77-6f03-465d-89b3-ffe50b37a532"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">MANDATORY</span></p>",
                                            "richText": true,
                                            "expand": true,
                                            "isActive": false,
                                            "uid": "650292ec-7c4c-4db3-8a32-ef96a23209ef"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">REQUIRES_NEW</span></p>",
                                            "richText": true,
                                            "expand": true,
                                            "isActive": false,
                                            "uid": "3d03a170-535d-42d3-939a-7db219fbee49"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">NOT_SUPPORTED</span></p>",
                                            "richText": true,
                                            "expand": true,
                                            "isActive": false,
                                            "uid": "ab463feb-0f9b-4fa3-b8b8-cb63a5c1d60e"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">NEVER</span></p>",
                                            "richText": true,
                                            "expand": true,
                                            "isActive": false,
                                            "uid": "3fe0c764-6ad9-4757-8913-0648c4ff6398"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">NESTED</span></p>",
                                            "richText": true,
                                            "expand": true,
                                            "isActive": false,
                                            "uid": "99ef4123-d1d4-4465-8dea-ba207a306742"
                                        },
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "text": "<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Spring设计模式</span></p>",
                    "note": "<div>Spring框架本身并没有特定的设计模式，但它在应用开发中广泛使用了一些经典的设计模式，以提供解耦、灵活性和可扩展性。以下是一些在Spring中常见的设计模式：</div><ol><li>依赖注入（Dependency Injection）：Spring通过依赖注入实现了控制反转（IoC）的设计模式。通过将对象的依赖关系交给容器来管理，实现了松耦合和可测试性。</li><li>单例模式（Singleton Pattern）：Spring中的Bean默认是单例的，通过在容器中维护单个实例，提供了对象的共享和重复利用。</li><li>工厂模式（Factory Pattern）：Spring使用工厂模式来创建和管理Bean对象。通过Bean工厂或应用上下文（Application Context）来创建Bean实例，隐藏了具体实现，提供了更高的抽象级别。</li><li>观察者模式（Observer Pattern）：Spring的事件机制基于观察者模式。通过定义事件和监听器，实现了模块之间的解耦和事件的发布与订阅。</li><li>模板方法模式（Template Method Pattern）：Spring提供了各种模板类和回调接口，例如JdbcTemplate和HibernateTemplate，通过模板方法模式封装了常见的操作流程，提供了一致的编程接口。</li><li>适配器模式（Adapter Pattern）：Spring的适配器模式用于将现有的类或接口适配为目标接口。例如，通过HandlerAdapter将不同类型的控制器适配为统一的处理器接口。</li><li>装饰器模式（Decorator Pattern）：Spring的装饰器模式用于扩展现有的功能。例如，通过AOP（面向切面编程）可以在不修改原有代码的情况下，添加额外的横切关注点。</li><li>代理模式（Proxy Pattern）：Spring的AOP基于代理模式实现。通过代理对象包装目标对象，实现了横切逻辑和目标逻辑的分离。</li></ol><div>这些设计模式在Spring中被广泛应用，使得应用开发更加灵活、可扩展和可维护。同时，Spring框架本身也提供了许多辅助工具和类，以支持这些设计模式的实现和应用。</div>",
                    "richText": true,
                    "expand": true,
                    "isActive": false,
                    "uid": "cdaffff6-b19f-4113-84d3-1cf8a9d898b2"
                },
                "children": [
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">单例模式</span></p>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "5b5fd95f-0854-4fef-8329-89bf94641713"
                        },
                        "children": [
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">饿汉式（Eager Initialization）</span></p>",
                                    "note": "<div>单例对象在类加载时就被创建，因此在整个程序运行期间都可以直接使用单例对象。饿汉式单例模式的实现简单直接，但可能会造成资源的浪费，因为即使在某些情况下单例对象并未被使用，它仍然会被创建。</div>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "da8afe70-888a-480f-a10c-8441b489aecf"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">实现方式</span></p>",
                                            "note": "<div>public class Singleton {<br>&nbsp; &nbsp; private static Singleton instance = new Singleton();<br><br>&nbsp; &nbsp; private Singleton() {<br>&nbsp; &nbsp; &nbsp; &nbsp; // 私有化构造函数<br>&nbsp; &nbsp; }<br><br>&nbsp; &nbsp; public static Singleton getInstance() {<br>&nbsp; &nbsp; &nbsp; &nbsp; return instance;<br>&nbsp; &nbsp; }<br>}</div>",
                                            "richText": true,
                                            "expand": true,
                                            "isActive": false,
                                            "uid": "1f8054dd-8ee3-40bd-9106-32c38144281a"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">懒汉式（Lazy Initialization）</span></p>",
                                    "note": "<div>单例对象在第一次使用时才被创建。懒汉式单例模式的实现相对复杂，需要考虑线程安全性，以及在多线程环境下保证只创建一个实例的问题。</div>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "2a738a80-692e-493e-98cc-ee9bc0969dd2"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">实现方式</span></p>",
                                            "note": "<div>public class Singleton {<br>&nbsp; &nbsp; private static Singleton instance;<br><br>&nbsp; &nbsp; private Singleton() {<br>&nbsp; &nbsp; &nbsp; &nbsp; // 私有化构造函数<br>&nbsp; &nbsp; }<br><br>&nbsp; &nbsp; public static synchronized Singleton getInstance() {<br>&nbsp; &nbsp; &nbsp; &nbsp; if (instance == null) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instance = new Singleton();<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; return instance;<br>&nbsp; &nbsp; }<br>}</div>",
                                            "richText": true,
                                            "expand": true,
                                            "isActive": false,
                                            "uid": "dd84bdf3-3247-401a-8bd9-8680be61e378"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">线程安全</span></p>",
                                    "note": "<div>在多线程环境下使用懒汉式单例模式时，需要考虑线程安全性。上述示例中使用了 synchronized 关键字来保证线程安全，但这会引入额外的开销。为了避免每次获取实例都进行同步，可以使用双重检查锁定（Double-Checked Locking）或者静态内部类的方式来实现懒汉式单例模式的线程安全性。</div><div>除了以上两种常见的单例模式，还有其他变种的实现方式，如基于静态内部类、枚举等，它们也可以实现单例模式，并具有一定的优点和特点。</div>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "0e72efce-1e8e-496a-bd24-466e149cac9e"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">工厂模式</span></p>",
                            "richText": true,
                            "expand": true,
                            "isActive": false,
                            "uid": "20cbc038-db82-4192-baf6-d3054ccaad2b"
                        },
                        "children": [
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">简单工厂模式（Simple Factory Pattern）</span></p>",
                                    "note": "<div>简单工厂模式通过一个工厂类来创建对象，根据传入的参数或条件决定创建哪种具体类型的对象。客户端只需要和工厂类进行交互，而不需要直接与具体对象进行耦合。简单工厂模式适用于对象的创建逻辑相对简单且不经常变化的情况。</div>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "44da8506-b74a-4893-a0ab-f4efda5ac219"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">实现方式</span></p>",
                                            "note": "<div>// 抽象产品接口<br>interface Product {<br>&nbsp; &nbsp; void operation();<br>}<br><br>// 具体产品类A<br>class ConcreteProductA implements Product {<br>&nbsp; &nbsp; @Override<br>&nbsp; &nbsp; public void operation() {<br>&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(\"ConcreteProductA operation\");<br>&nbsp; &nbsp; }<br>}<br><br>// 具体产品类B<br>class ConcreteProductB implements Product {<br>&nbsp; &nbsp; @Override<br>&nbsp; &nbsp; public void operation() {<br>&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(\"ConcreteProductB operation\");<br>&nbsp; &nbsp; }<br>}<br><br>// 简单工厂类<br>class SimpleFactory {<br>&nbsp; &nbsp; public static Product createProduct(String type) {<br>&nbsp; &nbsp; &nbsp; &nbsp; if (type.equals(\"A\")) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return new ConcreteProductA();<br>&nbsp; &nbsp; &nbsp; &nbsp; } else if (type.equals(\"B\")) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return new ConcreteProductB();<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; return null;<br>&nbsp; &nbsp; }<br>}<br><br>// 客户端代码<br>public class Main {<br>&nbsp; &nbsp; public static void main(String[] args) {<br>&nbsp; &nbsp; &nbsp; &nbsp; Product productA = SimpleFactory.createProduct(\"A\");<br>&nbsp; &nbsp; &nbsp; &nbsp; productA.operation(); // 输出：ConcreteProductA operation<br><br>&nbsp; &nbsp; &nbsp; &nbsp; Product productB = SimpleFactory.createProduct(\"B\");<br>&nbsp; &nbsp; &nbsp; &nbsp; productB.operation(); // 输出：ConcreteProductB operation<br>&nbsp; &nbsp; }<br>}</div>",
                                            "richText": true,
                                            "expand": true,
                                            "isActive": false,
                                            "uid": "c507cf46-8207-488a-92e4-45572aa648ee"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">工厂方法模式（Factory Method Pattern）</span></p>",
                                    "note": "<div>工厂方法模式定义了一个抽象的工厂类，其中包含一个创建对象的抽象方法，具体的对象创建由子类实现。每个具体的对象都有对应的工厂类，客户端通过与工厂类交互来获取所需的对象。工厂方法模式可以实现对象的多态性，使得系统更加灵活，能够根据需要扩展新的对象类型。</div>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "94f5053f-fc47-456b-941d-47d1a375775f"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">实现方式</span></p>",
                                            "note": "<div>// 抽象产品接口<br>interface Product {<br>&nbsp; &nbsp; void operation();<br>}<br><br>// 具体产品类A<br>class ConcreteProductA implements Product {<br>&nbsp; &nbsp; @Override<br>&nbsp; &nbsp; public void operation() {<br>&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(\"ConcreteProductA operation\");<br>&nbsp; &nbsp; }<br>}<br><br>// 具体产品类B<br>class ConcreteProductB implements Product {<br>&nbsp; &nbsp; @Override<br>&nbsp; &nbsp; public void operation() {<br>&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(\"ConcreteProductB operation\");<br>&nbsp; &nbsp; }<br>}<br><br>// 抽象工厂类<br>interface Factory {<br>&nbsp; &nbsp; Product createProduct();<br>}<br><br>// 具体工厂类A<br>class ConcreteFactoryA implements Factory {<br>&nbsp; &nbsp; @Override<br>&nbsp; &nbsp; public Product createProduct() {<br>&nbsp; &nbsp; &nbsp; &nbsp; return new ConcreteProductA();<br>&nbsp; &nbsp; }<br>}<br><br>// 具体工厂类B<br>class ConcreteFactoryB implements Factory {<br>&nbsp; &nbsp; @Override<br>&nbsp; &nbsp; public Product createProduct() {<br>&nbsp; &nbsp; &nbsp; &nbsp; return new ConcreteProductB();<br>&nbsp; &nbsp; }<br>}<br><br>// 客户端代码<br>public class Main {<br>&nbsp; &nbsp; public static void main(String[] args) {<br>&nbsp; &nbsp; &nbsp; &nbsp; Factory factoryA = new ConcreteFactoryA();<br>&nbsp; &nbsp; &nbsp; &nbsp; Product productA = factoryA.createProduct();<br>&nbsp; &nbsp; &nbsp; &nbsp; productA.operation(); // 输出：ConcreteProductA operation<br><br>&nbsp; &nbsp; &nbsp; &nbsp; Factory factoryB = new ConcreteFactoryB();<br>&nbsp; &nbsp; &nbsp; &nbsp; Product productB = factoryB.createProduct();<br>&nbsp; &nbsp; &nbsp; &nbsp; productB.operation(); // 输出：ConcreteProductB operation<br>&nbsp; &nbsp; }<br>}</div>",
                                            "richText": true,
                                            "expand": true,
                                            "isActive": false,
                                            "uid": "7a4f7569-052c-4eb5-a873-37ec449258d2"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">抽象工厂模式（Abstract Factory Pattern）</span></p>",
                                    "note": "<div>抽象工厂模式提供了一种创建一系列相关或相互依赖对象的接口，而无需指定具体的类。它包含多个抽象的工厂类，每个工厂类负责创建一组相关的对象。客户端通过与抽象工厂类进行交互，可以获得一组相关的对象，从而实现对象的族群间的替换和灵活性。抽象工厂模式适用于需要创建一系列相互关联的对象，且这些对象需要满足统一的约束条件。</div>",
                                    "richText": true,
                                    "expand": true,
                                    "isActive": false,
                                    "uid": "6725a1c1-0e10-4dc2-91d1-82fc1bfa58f2"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "text": "<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">实现方式</span></p>",
                                            "note": "<div>// 抽象产品接口A<br>interface ProductA {<br>&nbsp; &nbsp; void operationA();<br>}<br><br>// 具体产品类A1<br>class ConcreteProductA1 implements ProductA {<br>&nbsp; &nbsp; @Override<br>&nbsp; &nbsp; public void operationA() {<br>&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(\"ConcreteProductA1 operationA\");<br>&nbsp; &nbsp; }<br>}<br><br>// 具体产品类A2<br>class ConcreteProductA2 implements ProductA {<br>&nbsp; &nbsp; @Override<br>&nbsp; &nbsp; public void operationA() {<br>&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(\"ConcreteProductA2 operationA\");<br>&nbsp; &nbsp; }<br>}<br><br>// 抽象产品接口B<br>interface ProductB {<br>&nbsp; &nbsp; void operationB();<br>}<br><br>// 具体产品类B1<br>class ConcreteProductB1 implements ProductB {<br>&nbsp; &nbsp; @Override<br>&nbsp; &nbsp; public void operationB() {<br>&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(\"ConcreteProductB1 operationB\");<br>&nbsp; &nbsp; }<br>}<br><br>// 具体产品类B2<br>class ConcreteProductB2 implements ProductB {<br>&nbsp; &nbsp; @Override<br>&nbsp; &nbsp; public void operationB() {<br>&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(\"ConcreteProductB2 operationB\");<br>&nbsp; &nbsp; }<br>}<br><br>// 抽象工厂接口<br>interface AbstractFactory {<br>&nbsp; &nbsp; ProductA createProductA();<br>&nbsp; &nbsp; ProductB createProductB();<br>}<br><br>// 具体工厂类1<br>class ConcreteFactory1 implements AbstractFactory {<br>&nbsp; &nbsp; @Override<br>&nbsp; &nbsp; public ProductA createProductA() {<br>&nbsp; &nbsp; &nbsp; &nbsp; return new ConcreteProductA1();<br>&nbsp; &nbsp; }<br><br>&nbsp; &nbsp; @Override<br>&nbsp; &nbsp; public ProductB createProductB() {<br>&nbsp; &nbsp; &nbsp; &nbsp; return new ConcreteProductB1();<br>&nbsp; &nbsp; }<br>}<br><br>// 具体工厂类2<br>class ConcreteFactory2 implements AbstractFactory {<br>&nbsp; &nbsp; @Override<br>&nbsp; &nbsp; public ProductA createProductA() {<br>&nbsp; &nbsp; &nbsp; &nbsp; return new ConcreteProductA2();<br>&nbsp; &nbsp; }<br><br>&nbsp; &nbsp; @Override<br>&nbsp; &nbsp; public ProductB createProductB() {<br>&nbsp; &nbsp; &nbsp; &nbsp; return new ConcreteProductB2();<br>&nbsp; &nbsp; }<br>}<br><br>// 客户端代码<br>public class Main {<br>&nbsp; &nbsp; public static void main(String[] args) {<br>&nbsp; &nbsp; &nbsp; &nbsp; AbstractFactory factory1 = new ConcreteFactory1();<br>&nbsp; &nbsp; &nbsp; &nbsp; ProductA productA1 = factory1.createProductA();<br>&nbsp; &nbsp; &nbsp; &nbsp; productA1.operationA(); // 输出：ConcreteProductA1 operationA<br><br><br></div>",
                                            "richText": true,
                                            "expand": true,
                                            "isActive": false,
                                            "uid": "58fb3ef5-0017-4591-a1b7-8fc31842ace5"
                                        },
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        ]
    },
    "theme": {
        "template": "classic4",
        "config": {}
    },
    "view": {
        "transform": {
            "scaleX": 1,
            "scaleY": 1,
            "shear": 0,
            "rotate": 0,
            "translateX": 0,
            "translateY": 0,
            "originX": 0,
            "originY": 0,
            "a": 1,
            "b": 0,
            "c": 0,
            "d": 1,
            "e": 0,
            "f": 0
        },
        "state": {
            "scale": 1,
            "x": 0,
            "y": 0,
            "sx": 0,
            "sy": 0
        }
    }
}