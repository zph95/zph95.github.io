{"root":{"data":{"text":"<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 24px;\n      font-weight: bold;\n      font-style: normal;\n      text-decoration: none\n    \">中间件</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"f120b9ee-1006-4247-b311-56c7e96638fb"},"children":[{"data":{"text":"<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">kafka</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"a7471a88-eef5-4bbe-865d-4b3ee4249f26"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">消息队列的作用</span></p>","note":"<div>消息队列有很多使用场景，比较常见的有3个：解耦、异步、削峰。<br><br></div><ol><li>解耦：传统的软件开发模式，各个模块之间相互调用，数据共享，每个模块都要时刻关注其他模块的是否更改或者是否挂掉等等，使用消息队列，可以避免模块之间直接调用，将所需共享的数据放在消息队列中，对于新增业务模块，只要对该类消息感兴趣，即可订阅该类消息，对原有系统和业务没有任何影响，降低了系统各个模块的耦合度，提高了系统的可扩展性。</li><li>异步：消息队列提供了异步处理机制，在很多时候应用不想也不需要立即处理消息，允许应用把一些消息放入消息中间件中，并不立即处理它，在之后需要的时候再慢慢处理。</li><li>削峰：在访问量骤增的场景下，需要保证应用系统的平稳性，但是这样突发流量并不常见，如果以这类峰值的标准而投放资源的话，那无疑是巨大的浪费。使用消息队列能够使关键组件支撑突发访问压力，不会因为突发的超负荷请求而完全崩溃。消息队列的容量可以配置的很大，如果采用磁盘存储消息，则几乎等于“无限”容量，这样一来，高峰期的消息可以被积压起来，在随后的时间内进行平滑的处理完成，而不至于让系统短时间内无法承载而导致崩溃。在电商网站的秒杀抢购这种突发性流量很强的业务场景中，消息队列的强大缓冲能力可以很好的起到削峰作用。</li></ol>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"12bbeb17-264f-45af-b936-609994064504"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">解耦</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"08fe5488-6e00-46e3-93c0-ff72c87e2d8f"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">异步</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"37521bd5-c7bc-453c-b5ce-3dbd0c39203a"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">削峰</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"fe156ab9-5d3c-4490-bd43-4f2ff026f8ec"},"children":[]}]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">如何保证顺序消费</span></p>","note":"<div>对于 Kafka 来说，一个 topic 下同一个 partition 中的消息肯定是有序的，生产者在写的时候可以指定一个 key，通过我们会用订单号作为 key，这个 key 对应的消息都会发送到同一个 partition 中，所以消费者消费到的消息也一定是有序的。<br><br>导致最终乱序是由于消费者端需要使用多线程并发处理消息来提高吞吐量，比如消费者消费到了消息以后，开启 32 个线程处理消息，每个线程线程处理消息的快慢是不一致的，所以才会导致最终消息有可能不一致。<br><br></div><div>所以对于 Kafka 的消息顺序性保证，其实我们只需要保证同一个订单号的消息只被同一个线程处理的就可以了。由此我们可以在线程处理前增加个内存队列，每个线程只负责处理其中一个内存队列的消息，同一个订单号的消息发送到同一个内存队列中即可。如下图：<br><br></div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"cfe1c943-1522-46fb-824d-2c056aebe3ee"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">如何保证不重复消费</span></p>","note":"<ol><li>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update一下。</li><li>比如你是写redis，那没问题了，反正每次都是set，天然幂等性。</li><li>生产者发送每条数据的时候，里面加一个全局唯一的id，类似订单id之类的东西，然后你这里消费到了之后，先根据这个id去比如redis里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个id写redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</li></ol><div>还有比如基于数据库的唯一键来保证重复数据不会重复插入多条<br><br></div><div><br></div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"500dc767-9af1-47b7-bb20-7598501cc1af"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">消息处理失败</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"c24095a2-958c-4fb4-a5a7-77241cb46216"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">核心业务队列</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"586a4cac-e998-4995-a42c-30a2254eca3d"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">死信队列</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"6188b9a9-4900-4e13-b303-f71233ddb8c1"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">延时队列</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"3efffe2b-a458-4aad-bbad-fb52ba5fddb3"},"children":[]}]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">推消息和拉消息</span></p>","note":"<div><u>推模式：<br></u><br></div><div>推模式是服务器端根据用户需要，由目的、按时将用户感兴趣的信息主动发送到用户的客户端。<br><br></div><div>优点：<br><br></div><ul><li>对用户要求低，方便用户获取需要的信息；</li><li>及时性好，服务器端及时地向客户端推送更新动态信息，吞吐量大。</li></ul><div>缺点：<br><br></div><ul><li>不能确保发送成功，推模式采用广播方式，只有服务器端和客户端在同一个频道上，推模式才有效，用户才能接收到信息；</li><li>没有信息状态跟踪，推模式采用开环控制技术，一个信息推送后的状态，比如客户端是否接收等，无从得知；</li><li>针对性较差。推送的信息可能并不能满足客户端的个性化需求。</li></ul><div><u>拉模式：<br></u><br></div><div>拉模式是客户端主动从服务器端获取信息。<br><br></div><div>优点：<br><br></div><ul><li>针对性强，能满足客户端的个性化需求；</li><li>信息传输量较小，网络中传输的只是客户端的请求和服务器端对该请求的响应；</li><li>服务器端的任务轻。服务器端只是被动接收查询，对客户端的查询请求做出响应。</li></ul><div>缺点：<br><br></div><ul><li>实时性较差，针对于服务器端实时更新的信息，客户端难以获取实时信息；</li><li>对于客户端用户的要求较高，需要对服务器端具有一定的了解。</li></ul>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"7a5a19b9-4aa9-47a9-905b-19ef8267296e"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">和RabbitMq的区别</span></p>","note":"<div>在实际生产应用中，通常会使用Kafka作为消息传输的数据管道，RabbitMQ作为交易数据作为数据传输管道，主要的取舍因素则是是否存在丢数据的可能。RabbitMQ在金融场景中经常使用，具有较高的严谨性，数据丢失的可能性更小，同时具备更高的实时性。而Kafka优势主要体现在吞吐量上，虽然可以通过策略实现数据不丢失，但从严谨性角度来讲，大不如RabbitMQ。而且由于Kafka保证每条消息最少送达一次，有较小的概率会出现数据重复发送的情况。详细来说，它们之间主要有如下的区别：<br><br></div><ol><li>应用场景方面<br><br></li><li>RabbitMQ：用于实时的，对可靠性要求较高的消息传递上。<br><br></li><li>Kafka：用于处于活跃的流式数据，大数据量的数据处理上。<br><br></li><li>架构模型方面<br><br></li><li>RabbitMQ：以broker为中心，有消息的确认机制。<br><br></li><li>Kafka：以consumer为中心，没有消息的确认机制。<br><br></li><li>吞吐量方面<br><br></li><li>RabbitMQ：支持消息的可靠的传递，支持事务，不支持批量操作，基于存储的可靠性的要求存储可以采用内存或硬盘，吞吐量小。<br><br></li><li>Kafka：内部采用消息的批量处理，数据的存储和获取是本地磁盘顺序批量操作，消息处理的效率高，吞吐量高。<br><br></li><li>集群负载均衡方面<br><br></li><li>RabbitMQ：本身不支持负载均衡，需要loadbalancer的支持。<br><br></li><li>Kafka：采用zookeeper对集群中的broker，consumer进行管理，可以注册topic到zookeeper上，通过zookeeper的协调机制，producer保存对应的topic的broker信息，可以随机或者轮询发送到broker上，producer可以基于语义指定分片，消息发送到broker的某个分片上。<br><br></li></ol>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"8b0ab900-ec7c-41a2-9289-5169cc80db92"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">和RocketMq区别</span></p>","note":"<div>Kafka和RocketMQ都是流行的分布式消息中间件，用于实现高可靠、高吞吐量的消息传递系统。它们在设计和功能上有一些区别，下面是它们之间的主要区别：</div><ol><li>架构和设计：<ul><li>Kafka：Kafka是一个分布式发布-订阅系统，采用了高度可扩展的分布式架构。它使用分布式日志存储模型，消息以Topic为单位进行归类，并通过分区（Partition）进行水平扩展和负载均衡。</li><li>RocketMQ：RocketMQ是一个队列模型的消息中间件，采用了基于主题（Topic）和队列（Queue）的消息存储模型。消息通过Topic进行归类，每个Topic下有多个队列，每个队列只有一个消费者。</li></ul></li><li>消息顺序性：<ul><li>Kafka：Kafka保证了同一分区内的消息顺序性，即同一分区的消息按照发送顺序进行消费。但不保证全局顺序，不同分区的消息可能会被并行处理。</li><li>RocketMQ：RocketMQ在同一队列中保证了消息的顺序性，即同一队列的消息按照发送顺序进行消费。同时，RocketMQ还支持顺序消息，可以确保全局顺序。</li></ul></li><li>消息可靠性：<ul><li>Kafka：Kafka使用多副本机制来保证消息的可靠性。消息被复制到多个副本，当主副本发生故障时，可以从副本中进行恢复，保证消息的持久性和高可靠性。</li><li>RocketMQ：RocketMQ采用主从同步和异步刷盘的方式来保证消息的可靠性。消息先被写入主节点，然后通过主从同步复制到从节点，再进行异步刷盘。这种方式可以提供较高的消息可靠性。</li></ul></li><li>生态系统和社区支持：<ul><li>Kafka：Kafka拥有庞大的开源社区支持，具有丰富的生态系统和周边工具。它广泛应用于大数据领域，与Apache Hadoop、Spark等工具集成紧密。</li><li>RocketMQ：RocketMQ的生态系统相对较小，社区支持相对较弱。它在阿里巴巴内部得到广泛应用，作为阿里云的消息队列产品。</li></ul></li><li>扩展性：<ul><li>Kafka：Kafka具有较高的可扩展性，可以通过增加分区来实现水平扩展和负载均衡。它适用于处理大规模的消息流。</li><li>RocketMQ：RocketMQ的扩展性相对较弱，对于扩展性的需求较小的场景更为合适。</li></ul></li></ol><div>总体而言，Kafka适用于高吞吐量、大规模的消息处理场景，例如日志收集、流式处理等；而RocketMQ则适用于对顺序性和消息可靠性要求较高的场景，例如订单处理、事务消息等。选择适合自己业务需求的消息中间件非常重要。</div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"ba143357-7117-48f6-9472-69e268411106"},"children":[]}]},{"data":{"text":"<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">dubbo</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"84d9a0d1-7507-4caa-be41-1dc4e60cbc8c"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">RPC ( Remote Procedure Call)</span></p>","note":"<div><strong><br>2</strong><a href=\"https://link.zhihu.com/?target=https%3A//gitee.com/souyunku/NewDevBooks/blob/master/docs/Dubbo/Dubbo%25E9%259D%25A2%25E8%25AF%2595%25E9%25A2%2598%25E9%2599%2584%25E7%25AD%2594%25E6%25A1%2588%25E6%25B1%2587%25E6%2580%25BB%25EF%25BC%25882021%25E5%25B9%25B4Dubbo%25E9%259D%25A2%25E8%25AF%2595%25E9%25A2%2598%25E5%258F%258A%25E7%25AD%2594%25E6%25A1%2588%25E5%25A4%25A7%25E5%2585%25A8%25EF%25BC%2589.md%231rpc%25E4%25BD%25BF%25E7%2594%25A8%25E4%25BA%2586%25E5%2593%25AA%25E4%25BA%259B%25E5%2585%25B3%25E9%2594%25AE%25E6%258A%2580%25E6%259C%25AF%25E5%25BB%25BA%25E7%25AB%258B%25E9%2580%259A%25E4%25BF%25A1\"><strong>1、RPC使用了哪些关键技术，建立通信<br></strong></a><br></div><div><br>首先要解决通讯的问题：即A机器想要调用B机器，首先得建立起通信连接。<br><br></div><div><br>主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。<br><br></div><div><br>通常这个连接可以是按需连接（需要调用的时候就先建立连接，调用结束后就立马断掉），也可以是长连接（客户端和服务器建立起连接之后保持长期持有，不管此时有无数据包的发送，可以配合心跳检测机制定期检测建立的连接是否存活有效），多个远程过程调用共享同一个连接。<br><br></div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"1a212cbe-265f-426f-9f10-d948f327f558"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">接口服务层（Service）</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"c6f60112-9892-4fc0-a98a-319e84de1019"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">配置层（Config）</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"afb167bc-1aa9-4a02-8bfa-54336bb41d74"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">服务代理层（Proxy）</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"bbd9e84f-8855-4fed-ad15-439534b2c0b2"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">服务注册层（Registry</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"43d4145b-8c39-4bf2-9cda-a5edecfb4e82"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">路由层（Cluster）</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"98d6e803-df19-427d-95bd-e097a7490da7"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">监控层（Monitor）</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"36f211f9-d093-46fd-ba76-c0c4cc017473"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">信息交换层（Exchange)</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"64668489-6b38-4ea3-a2f1-8e5f1c99d1e8"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">网络传输层（Transport）</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"26ddb93d-e19a-4a73-85f2-c3121622587a"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">数据序列化层（Serialize）</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"0bb01782-7036-4c67-9dc1-24ccbb16ee5a"},"children":[]}]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">负载均衡策略</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"6b3cf84e-a25a-40b8-9b4a-b8b17513000b"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \"> Random LoadBalance: 随机选取提供者策略</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"552aa418-6eda-4157-9f41-0a5ab4d36016"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \"> RoundRobin LoadBalance: 轮循选取提供者策略</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"db6ba91b-56d2-4666-8235-4ddcdda16c56"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \"> LeastActive LoadBalance: 最少活跃调用策略</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"0ffaaec9-5344-469f-806e-4f0471e9045f"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \"> ConstantHash LoadBalance: 一致性 Hash 策略</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"3e91c9e1-d586-40d5-a72c-d173b484987e"},"children":[]}]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">通信框架netty</span></p>","note":"<div><a href=\"https://link.zhihu.com/?target=https%3A//gitee.com/souyunku/NewDevBooks/blob/master/docs/Dubbo/Dubbo%25E9%25AB%2598%25E7%25BA%25A7%25E9%259D%25A2%25E8%25AF%2595%25E9%25A2%2598%25E6%25B1%2587%25E6%2580%25BB%25E5%258F%258A%25E7%25AD%2594%25E6%25A1%2588%25EF%25BC%25882021%25E5%25B9%25B4Dubbo%25E9%259D%25A2%25E8%25AF%2595%25E9%25A2%2598%25E5%258F%258A%25E7%25AD%2594%25E6%25A1%2588%25E5%25A4%25A7%25E5%2585%25A8%25EF%25BC%2589.md%233dubbo-%25E4%25BD%25BF%25E7%2594%25A8%25E7%259A%2584%25E6%2598%25AF%25E4%25BB%2580%25E4%25B9%2588%25E9%2580%259A%25E4%25BF%25A1%25E6%25A1%2586%25E6%259E%25B6\"><strong><br>3、Dubbo 使用的是什么通信框架?<br></strong></a><br></div><div><br>默认使用 NIO Netty 框架<br><br></div><div><a href=\"https://link.zhihu.com/?target=https%3A//gitee.com/souyunku/NewDevBooks/blob/master/docs/Dubbo/Dubbo%25E9%25AB%2598%25E7%25BA%25A7%25E9%259D%25A2%25E8%25AF%2595%25E9%25A2%2598%25E6%25B1%2587%25E6%2580%25BB%25E5%258F%258A%25E7%25AD%2594%25E6%25A1%2588%25EF%25BC%25882021%25E5%25B9%25B4Dubbo%25E9%259D%25A2%25E8%25AF%2595%25E9%25A2%2598%25E5%258F%258A%25E7%25AD%2594%25E6%25A1%2588%25E5%25A4%25A7%25E5%2585%25A8%25EF%25BC%2589.md%234%25E6%259C%258D%25E5%258A%25A1%25E8%25B0%2583%25E7%2594%25A8%25E6%2598%25AF%25E9%2598%25BB%25E5%25A1%259E%25E7%259A%2584%25E5%2590%2597\"><strong><br>4、服务调用是阻塞的吗？<br></strong></a><br></div><div><br>默认是阻塞的，可以异步调用，没有返回值的可以这么做。<br><br></div><div><br>Dubbo 是基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个 Future 对象。<br><br></div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"042d4af7-bc7e-4c06-b4b1-0ee7420e5034"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">适用范围和适用场景</span></p>","note":"<div><br>适用范围：传入传出参数数据包较小（建议小于 100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用 dubbo 协议传输大文件或超大字符串。<br><br></div><div><br>适用场景：常规远程服务方法调用<br><br></div><div><br>dubbo 协议补充：<br><br></div><div><br>连接个数：单连接<br><br></div><div><br>连接方式：长连接<br><br></div><div><br>传输协议：TCP<br><br></div><div><br>传输方式：NIO 异步传输<br><br></div><div><br>序列化：Hessian 二进制序列化<br><br></div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"94ec994e-4a4e-49ca-a599-eb1e0e7b1952"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">spi</span></p>","note":"<div><strong><br>1</strong><a href=\"https://link.zhihu.com/?target=https%3A//gitee.com/souyunku/NewDevBooks/blob/master/docs/Dubbo/Dubbo%25E9%259D%25A2%25E8%25AF%2595%25E9%25A2%2598%25E9%2599%2584%25E7%25AD%2594%25E6%25A1%2588%25EF%25BC%25882021%25E5%25B9%25B4Dubbo%25E9%259D%25A2%25E8%25AF%2595%25E9%25A2%2598%25E5%258F%258A%25E7%25AD%2594%25E6%25A1%2588%25E5%25A4%25A7%25E6%25B1%2587%25E6%2580%25BB%25EF%25BC%2589.md%233dubbo-spi-%25E5%2592%258C-java-spi-%25E5%258C%25BA%25E5%2588%25AB\"><strong>3、Dubbo SPI 和 Java SPI 区别？<br></strong></a><br></div><div><strong><br>JDK SPI：<br></strong><br></div><div><br>JDK 标准的 SPI 会一次性加载所有的扩展实现，如果有的扩展很耗时，但也没用上，很浪费资源。所以只希望加载某个的实现，就不现实了<br><br></div><div><strong><br>DUBBO SPI：<br></strong><br></div><div><strong><br>1、</strong> 对 Dubbo 进行扩展，不需要改动 Dubbo 的源码<br><br></div><div><strong><br>2、</strong> 延迟加载，可以一次只加载自己想要加载的扩展实现。<br><br></div><div><strong><br>3、</strong> 增加了对扩展点 IOC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。<br><br></div><div><strong><br>4、</strong> Dubbo 的扩展机制能很好的支持第三方 IoC 容器，默认支持 Spring Bean。<br><br></div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"bf626896-ae8d-41aa-b5d0-77e0061fd944"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">和 SpringCloud 的区别</span></p>","note":"<div>Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断，而 Spring Cloud 诞生于微服务架构时代，考虑的是微服务治理的方方面面，并有强大的 Spring 家族优势支持，因此两个框架在开始目标就不一致，Dubbo 定位服务治理、Spirng Cloud 是一个生态。<br><br>二者最大的区别是：Dubbo 底层是使用 Netty 这样的 NIO 框架，是基于 TCP 协议传输的，配合 Hession 序列化完成 RPC 通信，而 SpringCloud 是基于 Http 协议加 Rest 接口调用远程过程的通信。<br><br>Http 请求会有更大的报文，占的带宽也会更多，但是 REST 相比 RPC 更为灵活，调用双方只依靠一纸契约，不存在代码级别的强依赖。<br><br></div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"a00484e7-c319-463a-92f5-77704e8797a0"},"children":[]}]},{"data":{"text":"<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">nacos</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"4078ebdd-d06e-413f-9953-2109702ce03e"},"children":[]}]},"theme":{"template":"classic4","config":{}},"layout":"verticalTimeline","config":{},"view":{"transform":{"scaleX":1,"scaleY":1,"shear":0,"rotate":0,"translateX":-259,"translateY":-48,"originX":0,"originY":0,"a":1,"b":0,"c":0,"d":1,"e":-259,"f":-48},"state":{"scale":1,"x":-259,"y":-48,"sx":0,"sy":0}}}