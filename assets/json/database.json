{"root":{"data":{"text":"<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 24px;\n      font-weight: bold;\n      font-style: normal;\n      text-decoration: none\n    \">数据库</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"e2df2573-d682-4cda-ab96-f9090439edf8"},"children":[{"data":{"text":"<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Mysql索引</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"766bdda8-124c-46b0-829f-e0ebb0e4ca41"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">索引的类型</span></p>","note":"<div>MySQL中常见的索引类型：</div><ol><li>B-Tree索引：B-Tree（平衡树）是MySQL默认的索引类型，适用于等值查询和范围查询。它将数据按照顺序存储在树结构中，支持快速的查找和排序操作。</li><li>唯一索引（Unique Index）：唯一索引要求索引列的值在表中唯一，用于保证数据的唯一性。可以在主键列上创建唯一索引，也可以在普通列上创建唯一索引。</li><li>主键索引（Primary Key Index）：主键索引是一种特殊的唯一索引，用于唯一标识表中的记录。每张表只能有一个主键索引，主键索引可以加速对表记录的唯一查找。</li><li>全文索引（Full-Text Index）：全文索引用于在文本数据中进行全文搜索。它能够快速查找包含特定关键字的记录，支持复杂的搜索和排序操作。</li><li>哈希索引（Hash Index）：哈希索引使用哈希函数将索引列的值映射为哈希码，适用于等值查询。它对于精确查找非常快速，但不支持范围查询和排序。</li><li>空间索引（Spatial Index）：空间索引用于存储和查询具有空间数据（如点、线、多边形）的记录。它支持空间查询和空间关系运算，用于地理信息系统（GIS）和位置数据的存储与查询。</li></ol><div>除了上述常见的索引类型，MySQL还支持组合索引（Composite Index）和前缀索引（Prefix Index）等特殊类型的索引。组合索引是指在多个列上创建的索引，可以提高多列条件查询的效率。前缀索引是指只对列值的一部分进行索引，可以减少索引的存储空间，但查询效率可能会降低。</div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"94dee507-3b19-4642-aece-83ae3f8b56d2"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">B-tree索引</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"63936f6a-5c63-4b05-815d-f19e75f411f1"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">唯一索引</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"c3d0ba0c-1bd9-4718-9b14-7c1d992c0a78"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">主键索引</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"b6232bbe-6df9-4ab4-850d-cb12c917f4ee"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">联合索引</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"974d4104-7b7b-4ca9-b2ce-e79ae135be39"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">全文索引</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"0455de06-ba30-491d-a192-5f29a6b5da85"},"children":[]}]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">如何创建索引</span></p>","note":"<div>在MySQL中，可以使用CREATE INDEX语句来创建索引。以下是创建索引的基本语法：</div><div>sql</div><pre>CREATE [UNIQUE] INDEX index_name\nON table_name (column1, column2, ...)\n<br></pre><div>其中，index_name是索引的名称，table_name是要创建索引的表名，column1, column2, ...是要在索引中包含的列名。</div><div>可以根据需要选择是否创建唯一索引（UNIQUE）。唯一索引要求索引列的值在表中唯一。如果省略了UNIQUE关键字，则创建的索引允许重复的值。</div><div>下面是一些示例：</div><ol><li>创建一个简单的B-Tree索引：</li></ol><div>sql</div><pre>CREATE INDEX idx_name ON my_table (name);\n<br></pre><div>这将在名为my_table的表的name列上创建一个名为idx_name的索引。</div><ol><li>创建一个唯一索引：</li></ol><div>sql</div><pre>CREATE UNIQUE INDEX idx_email ON users (email);\n<br></pre><div>这将在名为users的表的email列上创建一个唯一索引。</div><ol><li>创建一个组合索引：</li></ol><div>sql</div><pre>CREATE INDEX idx_name_age ON person (last_name, age);\n<br></pre><div>这将在名为person的表的last_name和age列上创建一个组合索引。</div><div>请注意，创建索引可能需要一些时间，特别是在大型表上创建索引时。因此，在为表创建索引之前，应仔细考虑哪些列需要索引，并确保索引的创建不会对数据库性能产生负面影响。</div><div>此外，还可以使用ALTER TABLE语句来添加索引，例如：</div><div>sql</div><pre>ALTER TABLE my_table ADD INDEX idx_name (name);\n<br></pre><div>这将在名为my_table的表的name列上添加一个名为idx_name的索引。</div><div>总之，通过CREATE INDEX语句或ALTER TABLE语句，可以在MySQL中创建各种类型的索引，以提高查询性能和数据访问效率。</div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"f803d290-7c98-4746-97bf-0db02eecc064"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">如何重构索引</span></p>","note":"<div>在MySQL中，可以使用ALTER TABLE语句来重构索引。重构索引可以包括添加、删除或修改现有索引。</div><div>以下是一些常见的重构索引操作：</div><ol><li>添加索引：</li></ol><div>sql</div><pre>ALTER TABLE table_name ADD INDEX index_name (column1, column2, ...);\n<br></pre><div>这将在名为table_name的表上添加一个名为index_name的索引，包括指定的列。</div><ol><li>删除索引：</li></ol><div>sql</div><pre>ALTER TABLE table_name DROP INDEX index_name;\n<br></pre><div>这将从名为table_name的表中删除名为index_name的索引。</div><ol><li>修改索引：<br>如果需要修改索引的定义，例如更改索引的列或名称，可以先删除旧的索引，然后再添加新的索引。</li></ol><div>sql</div><pre>ALTER TABLE table_name DROP INDEX index_name;\nALTER TABLE table_name ADD INDEX new_index_name (new_column1, new_column2, ...);\n<br></pre><div>这将删除名为index_name的索引，并添加一个名为new_index_name的新索引，包括新的列。</div><div>需要注意的是，在执行索引重构操作时，可能会对数据库的性能和可用性产生一定的影响，特别是在大型表上操作。因此，建议在非高峰期进行索引重构，并确保对数据库进行备份以防止意外情况发生。</div><div>此外，还可以使用工具如Percona Toolkit或pt-online-schema-change来执行索引重构操作，这些工具可以在不中断正常数据库操作的情况下进行索引修改。</div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"60e3bbe8-23d7-4429-b0a0-f57d39887d13"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">索引是否生效</span></p>","note":"<div>EXPLAIN语句用于查询优化，可以展示查询的执行计划，包括索引的使用情况。</div><div>以下是使用EXPLAIN语句来判断索引是否生效的一般步骤：</div><ol><li>执行EXPLAIN语句，加上要检查的查询语句。例如：</li></ol><div>sql</div><pre>EXPLAIN SELECT * FROM table_name WHERE column_name = 'value';\n<br></pre><div>将table_name替换为要查询的表名，column_name替换为要检查的列名，value替换为要检查的具体值。</div><ol><li>检查EXPLAIN的输出结果。关注以下几个重要的列：<ul><li>type：表示查询使用的访问方法，常见的类型有const、eq_ref、ref、range、index等。较好的情况是使用const或eq_ref，表示使用索引进行唯一或等值匹配。</li><li>key：表示查询使用的索引名称，如果该列为NULL，则表示没有使用索引。</li><li>rows：表示预计检索的行数，可以用于判断查询的效率。</li><li>Extra：表示额外的信息，例如Using index表示查询使用了覆盖索引。</li></ul></li></ol><div>通过分析EXPLAIN的输出结果，可以判断索引是否被正确选择和使用。以下是一些常见的判断标准：</div><ul><li>type列显示为const或eq_ref：表示查询使用了唯一索引或主键索引，索引效果很好。</li><li>type列显示为ref或range：表示查询使用了非唯一索引，但仍然能够有效地减少扫描的行数，索引效果较好。</li><li>type列显示为index：表示查询使用了索引，但需要扫描大部分的索引数据，可能需要进一步优化。</li><li>key列为NULL：表示查询未使用索引，可能需要添加适当的索引。</li><li>rows列显示的行数较大：表示查询涉及的行数较多，可能需要优化查询或添加更好的索引。</li></ul>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"e037383e-0baa-4b1f-b0ea-15585c5afa95"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">实现原理</span></p>","note":"<div>MySQL使用B+树作为索引的实现原理。B+树是一种自平衡的树型数据结构，它具有以下特点：</div><ol><li>有序性：B+树中的节点按照键值的大小顺序进行排序，使得范围查询更加高效。</li><li>平衡性：B+树通过自动调整节点的分裂和合并来保持树的平衡，使得查询的时间复杂度保持在O(log n)。</li><li>多路搜索：每个节点可以存储多个键值和对应的数据指针，减少了磁盘I/O操作，提高了查询效率。</li></ol><div>MySQL中的索引分为聚集索引和非聚集索引。</div><ol><li>聚集索引（Clustered Index）：聚集索引决定了表中数据的物理存储顺序。在InnoDB存储引擎中，主键索引就是聚集索引。当表按主键进行查询时，可以直接通过聚集索引找到对应的记录。</li><li>非聚集索引（Non-Clustered Index）：非聚集索引是基于表中的列创建的单独的索引结构，它的叶子节点中存储了索引列的值和指向对应数据行的指针。非聚集索引可以加速根据索引列进行查询的速度。</li></ol><div>MySQL中的索引是以页为单位进行存储的，每个页的大小通常是16KB。B+树的结构使得数据可以在磁盘上进行高效的顺序访问，而不需要读取整个表或索引。</div><div>当执行查询时，MySQL会根据查询条件和索引的选择性，通过B+树的搜索过程，逐级查找符合条件的数据。首先根据根节点找到对应的子节点，然后根据子节点的指针找到下一级的子节点，直到找到叶子节点。叶子节点存储了索引列的值和指向对应数据行的指针，从而可以定位到具体的数据。</div><div>索引的选择性是指索引列中不重复的值的比例。选择性越高，意味着索引的区分度越好，查询时需要读取的数据页越少，查询效率也就越高。因此，在设计索引时，选择具有高选择性的列作为索引可以提高查询性能。</div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"d7a7300f-efc7-41f8-bddd-ad06e946c52c"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">explain 语句的作用</span></p>","note":"<div>在MySQL中，EXPLAIN语句用于分析查询语句的执行计划，提供了关于查询优化器如何执行查询的详细信息。通过使用EXPLAIN语句，可以了解查询的执行方式、使用的索引、连接方式以及可能存在的性能问题。以下是EXPLAIN语句的作用：</div><ol><li>查询执行计划分析：<br>EXPLAIN语句能够显示查询语句的执行计划，包括表的访问顺序、连接方式（如JOIN操作）、索引的使用情况等。通过查看执行计划，可以了解MySQL优化器是如何选择执行计划的，帮助开发人员和DBA优化查询性能。</li><li>索引使用情况分析：<br>EXPLAIN语句可以告诉你查询语句是否使用了索引，以及使用了哪些索引。如果查询没有使用索引或使用了不合适的索引，可能导致查询性能下降。通过分析执行计划，可以判断是否需要创建、修改或删除索引来改善查询性能。</li><li>表访问顺序分析：<br>EXPLAIN语句可以显示查询中涉及的表的访问顺序。这对于理解查询中多个表之间的连接关系很有帮助。如果表的访问顺序不合理，可能导致性能问题。通过分析执行计划，可以调整查询语句或索引以改变表的访问顺序，提高查询性能。</li><li>查询优化和性能调优：<br>EXPLAIN语句提供了诸多信息，可以用于查询优化和性能调优。你可以根据执行计划的信息来评估查询的复杂性、索引使用情况、连接方式等，并根据需要进行调整。通过优化查询语句和索引设计，可以提高查询的执行效率和响应时间。</li></ol>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"c1b197ac-3ed4-45df-aadc-13e6e981f396"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">type</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"8c206297-b65a-4913-aac2-eb51eb1dcb0d"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">key</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"5a91342e-9372-4f69-8114-51b6e023f366"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">rows</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"c26e74d0-d618-4c82-9827-40344e097d65"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">extra</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"e6247d92-2f9b-40b7-9da3-498b1600d64d"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">filtered</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"5ba46cb6-1edc-410f-8f29-17fb87b97202"},"children":[]}]}]},{"data":{"text":"<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Mysql事务</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"a3abd766-8f4a-45d3-9662-39dff9c6c3cb"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">事务类型</span></p>","note":"<div>在MySQL中，支持以下几种事务类型：</div><ol><li>隐式事务（Implicit Transaction）：也称为自动提交事务。这是MySQL默认的事务模式，每个SQL语句都作为一个单独的事务执行，并自动提交。当执行一条SQL语句时，MySQL会自动将其作为一个事务提交，并将其结果持久化到数据库中。</li><li>显式事务（Explicit Transaction）：也称为手动提交事务。显式事务需要使用事务控制语句来开始、提交或回滚事务。常用的事务控制语句包括BEGIN（或START TRANSACTION）、COMMIT和ROLLBACK。<ul><li>BEGIN或START TRANSACTION：开始一个事务，标志着事务的起点。</li><li>COMMIT：提交事务，将事务中的修改保存到数据库。</li><li>ROLLBACK：回滚事务，撤销事务中的修改，恢复到事务开始之前的状态。</li></ul></li><li>自动提交模式（Autocommit Mode）：当显式事务被禁用时，MySQL处于自动提交模式。在自动提交模式下，每个SQL语句都被视为一个单独的事务，并自动提交。可以使用SET autocommit = 0来禁用自动提交，并使用显式事务控制语句来管理事务。</li><li>SAVEPOINT：SAVEPOINT语句用于在一个事务中创建一个保存点，以便在事务中的某个点进行部分回滚。可以使用ROLLBACK TO SAVEPOINT语句来回滚到指定的保存点。</li></ol><div>需要注意的是，事务功能在支持事务的存储引擎上才能生效，例如InnoDB。其他存储引擎如MyISAM不支持事务。</div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"2604825b-4756-42ae-a820-be5eecdf6e21"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">ACID特性实现原理</span></p>","note":"<div>ACID是数据库事务的四个基本特性，它们分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。下面是每个特性的实现原理：</div><ol><li>原子性（Atomicity）：原子性确保一个事务中的操作要么全部执行成功，要么全部回滚到事务开始前的状态，没有中间状态。原子性通过日志（log）和回滚段（rollback segments）来实现。在事务执行过程中，所有的修改操作都会被写入日志中，而不是直接写入磁盘。如果事务执行失败或回滚，可以使用日志和回滚段中的信息来撤消或恢复相关操作，从而保证原子性。</li><li>一致性（Consistency）：一致性确保事务在执行前后数据库的状态保持一致。数据库中的约束和规则定义了一致性的规则。在事务执行过程中，数据库会根据事务的要求和约束来执行操作，确保数据的一致性。如果事务执行失败或回滚，数据库会将数据恢复到事务开始前的状态，保持一致性。</li><li>隔离性（Isolation）：隔离性确保并发执行的事务相互之间不会产生影响，每个事务都感觉不到其他事务的存在。隔离性通过锁（lock）机制来实现。当一个事务修改数据时，会对相关的数据加锁，其他事务在访问该数据时需要等待或被阻塞，直到锁被释放。不同的隔离级别（如读未提交、读已提交、可重复读、串行化）定义了不同的锁机制和并发控制策略，以满足不同的隔离性要求。</li><li>持久性（Durability）：持久性确保事务提交后，其所做的修改将永久保存在数据库中，即使系统发生故障或崩溃。持久性通过日志和数据库的恢复机制来实现。在事务提交时，所有的修改操作都会被写入日志和事务日志中，并在数据库恢复时将这些日志应用于数据库，从而保证数据的持久性。</li></ol>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"f0bfe6f9-0ecc-4995-baff-b4de2fd5622a"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">原子性</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"d6840c25-c7ed-4c78-b0a5-621d3652add9"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">一致性</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"d6c163fe-0c4a-4dd2-a38b-8a0b828f3f57"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">隔离性</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"8ebcaa08-a953-4479-83a3-11bc605a6394"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">持久性</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"81ccefa1-92b5-4cf3-be4f-a2cd81b6748a"},"children":[]}]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">隔离级别</span></p>","note":"<div>MySQL支持多个事务隔离级别，用于控制并发事务之间的隔离程度。以下是MySQL支持的四个标准事务隔离级别：</div><ol><li>读未提交（Read Uncommitted）：最低的隔离级别，允许一个事务读取另一个事务尚未提交的数据。这种隔离级别可能导致脏读（Dirty Read），即读取到未提交的数据，可能出现不一致的结果。</li><li>读已提交（Read Committed）：在这个隔离级别下，一个事务只能读取到已经提交的数据。这样可以避免脏读，但可能会出现不可重复读（Non-Repeatable Read），即同一个事务内多次读取同一数据，但得到的结果不一致。</li><li>可重复读（Repeatable Read）：在这个隔离级别下，同一个事务内多次读取同一数据，得到的结果始终是一致的。MySQL的默认隔离级别就是可重复读。为了实现可重复读，MySQL使用了多版本并发控制（MVCC）机制，确保读操作不会受到其他事务的影响。</li><li>串行化（Serializable）：最高的隔离级别，它通过完全串行化事务的执行顺序，避免了脏读、不可重复读和幻读（Phantom Read）。在这个隔离级别下，事务之间完全互斥，可能导致并发性能下降，因为事务需要依次执行。</li></ol><div>除了这四个标准隔离级别，MySQL还支持在可重复读隔离级别上进行的一种特殊优化，即读写一致（Read Committed for Read Only）。在这个优化级别下，对于只读事务，MySQL将使用读已提交的隔离级别，以提高并发性能。</div><div>要设置MySQL的事务隔离级别，可以使用以下语句：</div><div><br></div><pre>SET TRANSACTION ISOLATION LEVEL &lt;隔离级别&gt;;\n<br></pre><div>其中，&lt;隔离级别&gt;可以是上述四个隔离级别之一。</div><div>需要注意的是，不同的隔离级别在性能和数据一致性方面有不同的权衡。较低的隔离级别可以提高并发性能，但可能导致读取到不一致的数据。较高的隔离级别可以保证数据的一致性，但可能会降低并发性能。因此，在选择隔离级别时，需要根据具体业务需求和性能要求进行权衡。</div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"f51bef31-3d3b-4eeb-8f19-8f5cb8d6acbc"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">读未提交</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"958a974d-d38b-4b3e-a0be-ce855c859590"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">读已提交</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"c7012676-ad86-4fe2-ad26-6640b9c823fa"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">可重复读</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"6082adb8-b45c-4588-ade5-6531792a9960"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">串行化</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"72c4afed-985e-48f0-80d1-ebed28e00b5f"},"children":[]}]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">隔离级别实现原理</span></p>","note":"<div>MySQL通过使用多版本并发控制（MVCC）机制实现不同的事务隔离级别。MVCC机制基于以下两个核心概念：版本号和回滚段。</div><ol><li>版本号（Versioning）：在MVCC中，每个数据行都有多个版本，每个版本都有一个唯一的版本号。版本号用于标识事务在读取或修改数据时所见的数据版本。当一个事务开始时，它会获得一个事务的ID，用于标识该事务的版本。当事务读取数据时，它只能看到在该事务开始之前已经提交的数据版本。</li><li>回滚段（Rollback Segments）：回滚段是用于存储旧版本数据的数据结构。当一个事务修改数据时，MySQL会将事务之前的版本保存在回滚段中，以便其他事务可以访问到旧版本的数据。如果一个事务需要回滚，MySQL可以使用回滚段中的旧版本数据来还原数据到事务开始之前的状态。</li></ol><div>根据不同的隔离级别，MVCC机制采取不同的策略来保证隔离性：</div><ol><li>读未提交（Read Uncommitted）：在这个隔离级别下，事务读取到其他事务尚未提交的数据。MySQL使用当前版本的数据，不进行任何额外的控制。</li><li>读已提交（Read Committed）：在这个隔离级别下，事务只能读取到已经提交的数据。MySQL会使用当前版本的数据，但在读取时会检查每个数据行的版本号，如果当前版本是未提交的，则读取到的是上一个提交的版本。</li><li>可重复读（Repeatable Read）：在这个隔离级别下，事务多次读取同一数据时，得到的结果始终是一致的。MySQL使用事务开始时的版本号作为读取的基准版本，事务期间不会看到其他事务对同一数据行的修改。当一个事务修改数据时，MySQL会生成一个新的版本，并将新版本的数据行指向旧版本的数据。这样，其他事务在读取数据时可以继续使用旧版本的数据。</li><li>串行化（Serializable）：在这个隔离级别下，事务之间完全互斥，每个事务必须按照顺序执行。MySQL使用锁机制来实现串行化隔离级别，确保事务之间的互斥性。当一个事务对数据进行读取或修改时，MySQL会对相关的数据行加锁，其他事务在访问该数据行时需要等待或被阻塞。</li></ol>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"d5986745-b058-4c80-995b-9fe2747b097f"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">日志</span></p>","note":"<div>在MySQL数据库中，有三种日志类型：redo log、undo log和bin log。它们分别用于确保事务的持久性、回滚和数据复制。<br><br>1. Redo Log（重做日志）：<br>&nbsp; &nbsp;Redo log是一种事务日志，用于确保事务的持久性和恢复能力。当执行事务时，对数据库的修改操作首先会被写入redo log中，然后再写入磁盘的数据文件。这样，即使数据库发生故障，通过重做日志可以将已提交的事务重新应用到数据文件，从而恢复数据库的一致性。<br><br>2. Undo Log（回滚日志）：<br>&nbsp; &nbsp;Undo log是一种事务日志，用于实现事务的回滚和MVCC（多版本并发控制）。在事务执行过程中，对数据库的修改操作会首先写入undo log中，然后才应用到数据文件。如果事务回滚或发生回滚操作，可以使用undo log中的信息来撤销事务对数据库的修改，恢复到事务开始前的状态。<br><br>3. Bin Log（二进制日志）：<br>&nbsp; &nbsp;Bin log是一种用于数据复制和恢复的日志。它记录了数据库的逻辑变更操作，包括对数据的插入、更新和删除操作。Bin log可以用于数据库的主从复制，将主数据库的变更操作记录在bin log中，然后从数据库通过解析bin log来复制主数据库的操作，从而保持主从数据库的一致性。<br><br>这三种日志在数据库的运行和维护中起着不同的作用。Redo log用于持久化事务的修改，确保数据的一致性和持久性；Undo log用于支持事务的回滚和MVCC；Bin log用于数据复制和恢复，实现主从数据库的同步。<br><br>值得注意的是，redo log和undo log是在数据库内部维护的，而bin log是以文件形式存储在数据库服务器上。此外，redo log和undo log通常是循环写入的，而bin log是追加写入的。</div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"82d9ecfe-1d9b-4eea-a4e1-b492ae589f60"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">redo log</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"557bfaa0-fa3e-4455-9465-6ef3ceeb1049"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">undo log</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"9d3c77e4-18cf-461b-a212-3cbbad2546b8"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">bin log</span></p>","note":"<div>MySQL的二进制日志（Binary Log，简称binlog）是一种事务日志，它记录了对MySQL数据库进行的所有数据修改操作，包括插入、更新和删除等操作。binlog的作用主要有以下几个方面：</div><ol><li>数据恢复：binlog可以用于数据库的恢复和备份。通过将binlog应用到一个空白的数据库实例上，可以还原数据库到binlog记录的某个时间点或特定的事务。这对于恢复误删除的数据、逻辑错误或灾难性故障非常有用。</li><li>数据复制：binlog用于数据库的主从复制。在主从复制中，主数据库将其修改操作记录到binlog中，从数据库通过读取binlog并应用相同的操作来复制主数据库的数据。这样可以实现数据的实时复制、数据的备份和读写分离等功能。</li><li>数据库同步：binlog可以用于数据同步和数据迁移。通过解析binlog中的操作记录，可以将数据同步到其他数据库或数据仓库中，实现不同数据库之间的数据同步和迁移。</li><li>审计和回溯：binlog记录了数据库的所有修改操作，可以用于审计和回溯数据的变更历史。通过分析binlog，可以了解到某个时间段内数据库的数据修改情况，追踪数据的变更过程，满足合规性要求和数据审计的需求。</li></ol><div>需要注意的是，binlog是MySQL服务器的一个功能，它默认是开启的。但是在一些特定情况下，如性能调优或者特定的应用场景下，可以选择关闭binlog来提高数据库的性能。</div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"b8437cfc-4860-4a88-bdc3-f2d2acdcd931"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">binlog的级别</span></p>","note":"<div>在MySQL中，可以通过设置binlog开启级别来指定binlog的记录方式和详细程度。MySQL提供了以下两种binlog开启级别：</div><ol><li>STATEMENT级别：在STATEMENT级别下，binlog记录的是执行的SQL语句，即每个修改操作的原始SQL语句。这意味着binlog中记录了每个事务执行的具体SQL语句，但并没有记录每个修改操作的具体行数据的变化情况。这是最基本的binlog记录级别，适用于大多数情况。</li><li>ROW级别：在ROW级别下，binlog记录的是每个修改操作的行级别变化情况，即记录了具体行数据的变化。对于每个被修改的行，binlog会记录其修改前与修改后的完整行数据。这使得binlog可以提供更详细的修改历史，但也增加了binlog的大小，并对性能产生一定的影响。</li></ol><div>可以通过在MySQL配置文件（如my.cnf或my.ini）中设置以下参数来指定binlog开启级别：</div><div>plaintext</div><div><br></div><pre># 设置binlog开启级别为STATEMENT\nbinlog_format = STATEMENT\n\n# 设置binlog开启级别为ROW\nbinlog_format = ROW\n<br></pre><div>需要注意的是，还有一个MIXED级别，它是STATEMENT级别和ROW级别的混合模式。在MIXED级别下，MySQL根据具体的操作类型和情况决定使用STATEMENT还是ROW来记录binlog。这可以在一定程度上兼顾性能和详细程度的需求。</div><div>选择适当的binlog开启级别要根据具体的需求和应用场景进行权衡。如果需要详细的行级别变化记录或者进行数据同步等高级操作，可以选择ROW级别。而对于一般的数据恢复、主从复制和审计等需求，STATEMENT级别通常已经足够。</div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"db809203-ca30-4268-8982-86159c784df9"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">statement级别</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"0e15bb51-c855-48e2-9718-c8065f3f91c7"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">row级别</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"9d4a0e07-0068-4c95-a435-892567b7112c"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">MIXED 混合级别</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"e27b562a-bcf5-4995-babd-1009e3ce04b7"},"children":[]}]}]}]}]},{"data":{"text":"<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Mysql锁</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"7371a1cb-3b2a-4246-a7c5-8b050cb9a8c9"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">锁的分类</span></p>","note":"<div>MySQL中的锁可以根据不同的维度进行分类。以下是MySQL中常见的锁分类：</div><ol><li>行级锁（Row-level Locks）：行级锁是最细粒度的锁，它可以在数据表的行级别上进行加锁。行级锁可以控制并发事务对同一数据表中不同行的访问。MySQL中的行级锁是通过在InnoDB存储引擎中实现的。行级锁提供了更高的并发性，但也会引入更多的开销。</li><li>表级锁（Table-level Locks）：表级锁是在数据表级别上进行加锁，它可以控制整个数据表的访问。表级锁可以对整个表进行读锁或写锁，阻止其他事务对该表的读取或写入。表级锁在MySQL中主要用于特定的场景，例如需要对整个表进行大规模的修改操作时。</li><li>页级锁（Page-level Locks）：页级锁是在数据表的页级别（通常是16KB）上进行加锁。每个页包含多行数据，页级锁可以控制对整个页的访问。页级锁在MySQL中主要用于MyISAM存储引擎，而在InnoDB存储引擎中，行级锁是更常见的选择。</li><li>共享锁（Shared Locks）：共享锁也称为读锁，它允许多个事务同时对同一资源进行读取，但不允许进行写操作。共享锁之间不会互相阻塞，因为多个事务可以同时读取同一资源。共享锁用于保证读取操作的一致性。</li><li>排他锁（Exclusive Locks）：排他锁也称为写锁，它只允许一个事务对资源进行写操作，并排斥其他事务的读取或写入。排他锁会阻塞其他事务的读写操作，直到持有锁的事务释放锁。排他锁用于保证写操作的原子性和一致性。</li></ol><div>需要注意的是，MySQL的不同存储引擎对锁的支持和实现方式可能有所不同。例如，InnoDB存储引擎支持行级锁，并使用多版本并发控制（MVCC）来提高并发性能，而MyISAM存储引擎则主要使用表级锁和页级锁。在使用锁时，需要根据具体的需求和存储引擎的特性选择适当的锁策略。</div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"100c47a1-39ee-4709-977c-adc953ab8d41"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">行级锁</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"96c602f0-435c-4968-833b-5f98e85050c9"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">页级锁</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"d99f44cb-374d-4de7-9bb5-72a27315241d"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">表级锁</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"9414158a-a3bc-4864-97da-6770dfc29f47"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">共享锁（读锁）</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"0b6c6e19-3bf6-42dc-a829-f38dd438874c"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">排他锁（写锁）</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"0416d7d3-a68e-4e17-8e25-f8ba7e8300b5"},"children":[]}]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">InnoDB中的行级锁实现方式</span></p>","note":"<div>在InnoDB存储引擎中，行级锁是通过多版本并发控制（MVCC）机制来实现的。MVCC机制为每个事务提供了一个独立的版本视图，使得多个事务可以并发地读取和修改同一数据表的不同行，同时保持数据的一致性和隔离性。</div><div>下面是InnoDB中行级锁的实现方式：</div><ol><li>版本号：每行数据都有一个隐藏的版本号，用于标识该行数据的版本。当一个事务开始时，它会获得一个唯一的事务ID（transaction ID），用于标识该事务的版本。事务开始时的事务ID称为事务的ReadView。</li><li>Undo日志：当一个事务修改一行数据时，InnoDB会将该行的旧版本数据记录在事务的undo日志中。这样，其他事务在读取该行时可以通过undo日志还原到旧版本的数据。Undo日志还用于实现事务的回滚操作。</li><li>快照读（Snapshot Read）：在可重复读隔离级别下，每个事务在开始时会创建一个快照，用于表示事务开始时的数据库状态。快照读保证了事务在整个事务期间看到的数据是一致的。当一个事务执行SELECT语句时，它只能读取到在事务开始之前已经提交的数据版本。</li><li>行锁：当一个事务对某一行数据进行修改时，InnoDB会为该行加上行级锁，阻止其他事务对该行的并发修改或加上排他锁的读取。其他事务可以继续读取该行的旧版本数据，或者读取未加锁的行。行锁的粒度可以是行、页或表，具体取决于事务的需求和并发情况。</li></ol>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"67a4f0b6-332f-4bfe-862e-13f8a8954a93"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">死锁的产生</span></p>","note":"<div>MySQL中死锁是指两个或多个事务相互等待对方持有的锁资源，从而导致它们无法继续执行并永远等待下去的情况。死锁的产生通常需要满足以下条件：</div><ol><li>互斥条件（Mutual Exclusion）：至少有一个资源只能同时被一个事务占用，即排它锁。</li><li>请求与保持条件（Hold and Wait）：一个事务在持有部分锁资源的同时，又请求其他事务占用的锁资源。</li><li>不可剥夺条件（No Preemption）：锁资源只能由持有者主动释放，不能被其他事务强制剥夺。</li><li>循环等待条件（Circular Wait）：多个事务之间形成一个循环等待的链条，每个事务都在等待下一个事务所占用的锁资源。</li></ol><div>当这些条件同时满足时，就会发生死锁。具体来说，MySQL中死锁的产生可以通过以下步骤解释：</div><ol><li>事务A请求锁资源X，并成功获得了锁。</li><li>事务B请求锁资源Y，并成功获得了锁。</li><li>事务A请求锁资源Y，但由于事务B已经持有了Y锁，所以事务A被阻塞，等待事务B释放Y锁。</li><li>事务B请求锁资源X，但由于事务A已经持有了X锁，所以事务B被阻塞，等待事务A释放X锁。</li></ol><div>此时，事务A和事务B都无法继续执行，并陷入了死锁状态。它们相互等待对方释放锁资源，导致无法继续进行下去。</div><div>MySQL的死锁检测机制会自动检测死锁的发生，并选择其中一个事务作为死锁的牺牲者，将其回滚，释放所占用的锁资源，从而解除死锁。被选择作为牺牲者的事务会回滚并重新执行，以避免数据不一致的问题。</div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"92d619cf-0df3-46ca-975a-b31a8df25468"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">死锁的解决办法</span></p>","note":"<div>解决死锁问题的方法通常包括以下几种：</div><ol><li>死锁避免（Deadlock Avoidance）：通过事务的调度和资源分配策略，避免发生死锁。这需要对事务和锁资源之间的依赖关系进行分析和评估，以预测可能导致死锁的情况，并采取相应的措施避免这些情况发生。例如，可以使用事务等级（Transaction Isolation Level）来控制锁的粒度，或者使用死锁检测算法来动态地判断是否存在死锁风险。</li><li>死锁检测与解除（Deadlock Detection and Resolution）：在发生死锁时，通过死锁检测算法检测到死锁的存在，并采取措施进行解除。常见的死锁检测算法包括资源分配图（Resource Allocation Graph）算法和等待图（Wait-for Graph）算法。解除死锁的方法可以是选择一个或多个事务作为牺牲者，回滚这些事务并释放它们所持有的锁资源，从而解除死锁。</li><li>超时机制（Timeouts）：为事务设置合理的超时时间，在超过一定时间后，如果事务仍然无法获取所需的锁资源，可以主动回滚事务并释放已经获取的锁资源，以避免长时间的等待和可能的死锁发生。超时机制可以结合死锁检测来使用，以更及时地发现和解决死锁问题。</li><li>锁粒度优化（Lock Granularity Optimization）：合理选择锁的粒度可以减少死锁的发生。如果锁的粒度太粗，例如表级锁，会导致并发度降低，容易发生死锁。相反，如果锁的粒度太细，例如行级锁，可能会增加死锁的概率。因此，需要根据具体情况优化锁的粒度，平衡并发性能和死锁风险。</li><li>优化事务操作顺序（Transaction Ordering Optimization）：调整事务的操作顺序，以减少不同事务之间产生死锁的可能性。例如，可以约定所有事务按照相同的顺序获取锁资源，避免交叉锁等待的情况。</li></ol>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"4d2b9a32-ad96-49c5-8482-803e42312cad"},"children":[]}]},{"data":{"text":"<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">redis数据类型</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"23c6516a-8c6e-4eed-9d12-80a0627038f0"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">字符串</span></p>","note":"<div>在Redis中，字符串（String）是一种基本的数据类型之一，用于存储和操作二进制安全的字符串数据。Redis的字符串类型具有以下特点：</div><ol><li>存储二进制安全数据：Redis的字符串类型可以存储任意二进制数据，不仅仅限于字符串。这使得字符串类型非常灵活，可以用于存储各种类型的数据，如文本、数字、序列化对象等。</li><li>高效的读写操作：Redis提供了一系列高效的操作命令，用于对字符串进行读写操作，包括获取值、设置值、追加值、获取子字符串、增减数值等。</li><li>原子性操作：Redis的字符串操作是原子性的，即一个操作的执行不会被其他操作所打断。这意味着在并发环境下，字符串操作可以保证数据的一致性。</li><li>应用场景广泛：字符串类型在Redis中被广泛应用，例如用作缓存、计数器、分布式锁等。由于其简单、高效和多功能的特性，字符串类型是Redis中最常用的数据类型之一。</li></ol><div>以下是一些常用的字符串类型的操作命令：</div><ul><li>SET key value: 设置指定 key 的值为给定的 value。</li><li>GET key: 获取指定 key 的值。</li><li>APPEND key value: 在指定 key 的值后追加字符串 value。</li><li>STRLEN key: 返回指定 key 的值的长度。</li><li>INCR key: 将指定 key 的值增加 1。</li><li>DECR key: 将指定 key 的值减少 1。</li><li>SETNX key value: 当指定 key 不存在时，设置 key 的值为给定的 value。</li></ul><div>除了基本的字符串类型外，Redis还提供了其他复杂的数据类型，如列表（List）、哈希（Hash）、集合（Set）和有序集合（Sorted Set），可以根据具体的需求选择适合的数据类型进行存储和操作。</div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"766f4176-e966-4ac6-99bb-9050b0d8c64e"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">哈希</span></p>","note":"<div>在Redis中，哈希（Hash）是一种用于存储和操作键值对的数据类型。哈希类型在Redis中被用于表示具有字段和值的对象，类似于关联数组或字典。哈希类型的特点如下：</div><ol><li>存储键值对：哈希类型将数据组织为键值对的形式，其中每个键对应一个值。这使得哈希类型非常适合存储和表示具有多个属性的对象。</li><li>高效的读写操作：Redis提供了一系列针对哈希类型的操作命令，可用于对字段和值进行读写操作。这些命令允许您以常量时间复杂度（O(1)）来访问、设置和修改哈希中的字段和值。</li><li>灵活的字段操作：哈希类型支持动态添加和删除字段，使得您可以根据需要动态地调整对象的属性。您可以对单个字段进行读写操作，也可以对多个字段进行批量操作。</li><li>适用于存储复杂数据：哈希类型的值可以是字符串、数字或二进制数据，因此可以存储各种类型的复杂数据结构，如JSON对象、用户配置、缓存条目等。</li></ol><div>以下是一些常用的哈希类型的操作命令：</div><ul><li>HSET key field value: 设置指定 key 的指定字段 field 的值为给定的 value。</li><li>HGET key field: 获取指定 key 的指定字段 field 的值。</li><li>HGETALL key: 获取指定 key 的所有字段和值。</li><li>HDEL key field [field ...]: 删除指定 key 中的一个或多个字段。</li><li>HKEYS key: 获取指定 key 的所有字段名。</li><li>HVALS key: 获取指定 key 的所有字段值。</li><li>HLEN key: 获取指定 key 中字段的数量。</li></ul>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"b275a0d4-ed6a-48e1-8909-59f96c057d6c"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">列表</span></p>","note":"<div>在Redis中，列表（List）是一种有序的、可重复的数据类型，用于存储一系列的元素。列表类型支持在头部和尾部进行元素的插入和删除操作，提供了对列表进行快速的读写和修改。</div><div>以下是列表类型的一些特点和常用操作命令：</div><ol><li>有序的元素集合：列表中的元素按照插入的顺序排列，可以包含重复的元素。列表中的元素可以是字符串、数字或二进制数据。</li><li>快速的插入和删除操作：列表类型提供了在头部和尾部进行元素插入和删除的操作命令，这些操作的时间复杂度为常量时间（O(1)）。</li><li>索引操作和范围操作：可以根据索引获取列表中的元素，索引从0开始，负数索引表示从列表尾部开始计数。还可以使用范围操作命令获取列表中指定范围的元素。</li><li>支持阻塞操作：列表类型的阻塞操作命令允许在列表为空时进行阻塞等待，直到列表中有新的元素插入或指定的超时时间到达。</li></ol><div>以下是一些常用的列表类型的操作命令：</div><ul><li>LPUSH key element [element ...]: 将一个或多个元素插入到列表的头部。</li><li>RPUSH key element [element ...]: 将一个或多个元素插入到列表的尾部。</li><li>LPOP key: 移除并返回列表头部的元素。</li><li>RPOP key: 移除并返回列表尾部的元素。</li><li>LINDEX key index: 返回列表中指定索引位置的元素。</li><li>LRANGE key start stop: 返回列表中指定范围的元素。</li><li>LLEN key: 返回列表的长度。</li></ul><div>列表类型在Redis中被广泛应用，例如消息队列、发布订阅系统、历史记录存储等场景。由于列表类型的有序性和灵活的操作，它可以有效地支持对元素的顺序操作和快速的数据访问。</div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"0e6c7131-0a70-41d1-8a47-b749258539ff"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">集合</span></p>","note":"<div>在Redis中，集合（Set）是一种无序的、不重复的数据类型，用于存储唯一的元素集合。集合类型提供了快速的插入、删除和判断元素是否存在的操作，以及集合间的交集、并集、差集等操作。</div><div>以下是集合类型的一些特点和常用操作命令：</div><ol><li>无序的元素集合：集合中的元素是无序的，每个元素都是唯一的，不允许重复。</li><li>快速的插入和删除操作：集合类型提供了将元素添加到集合和从集合中删除元素的操作命令，这些操作的时间复杂度为常量时间（O(1)）。</li><li>判断元素是否存在：可以通过命令快速判断一个元素是否存在于集合中，这对于去重和判断成员关系非常有用。</li><li>集合间的操作：Redis提供了集合间的交集、并集、差集等操作命令，可以对多个集合进行计算和操作。</li></ol><div>以下是一些常用的集合类型的操作命令：</div><ul><li>SADD key element [element ...]: 将一个或多个元素添加到集合中。</li><li>SREM key element [element ...]: 从集合中移除一个或多个元素。</li><li>SISMEMBER key element: 判断一个元素是否存在于集合中。</li><li>SMEMBERS key: 返回集合中的所有元素。</li><li>SCARD key: 返回集合的元素数量。</li><li>SINTER key [key ...]: 返回多个集合的交集。</li><li>SUNION key [key ...]: 返回多个集合的并集。</li><li>SDIFF key [key ...]: 返回多个集合的差集。</li></ul><div>集合类型在Redis中被广泛应用，例如社交网络中的关注列表、标签系统中的标签集合、排行榜中的排名集合等。由于集合类型的去重性和高效的操作，它可以提供快速的成员判断和集合计算功能。</div><div><br></div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"25874f58-7999-4a6f-926f-ca9c0baa5317"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">有序集合</span></p>","note":"<div>在Redis中，有序集合（Sorted Set）是一种有序的、不重复的数据类型，其中的每个成员都关联着一个分数（score），用于根据分数对成员进行排序。有序集合使用了类似于集合的数据结构，但每个成员都与一个分数相关联，这使得有序集合既可以根据成员的唯一性进行查找，又可以根据分数进行排序。</div><div>以下是有序集合类型的一些特点和常用操作命令：</div><ol><li>有序的成员集合：有序集合中的成员是唯一的，每个成员都关联着一个分数，用于排序成员。成员按照分数从小到大排序，相同分数的成员按照字典序排序。</li><li>快速的插入和删除操作：有序集合类型提供了将成员插入到集合和从集合中删除成员的操作命令，这些操作的时间复杂度为常量时间（O(1)）。</li><li>根据分数范围进行操作：可以根据指定的分数范围获取成员，包括获取指定范围内的成员数量、获取指定范围内的成员列表等。</li><li>支持成员唯一性和分数更新：由于成员是唯一的，可以根据成员唯一性进行查找和更新，也可以根据需要更新成员的分数。</li></ol><div>以下是一些常用的有序集合类型的操作命令：</div><ul><li>ZADD key score member [score member ...]: 将一个或多个成员添加到有序集合中，并关联指定的分数。</li><li>ZREM key member [member ...]: 从有序集合中移除一个或多个成员。</li><li>ZSCORE key member: 返回有序集合中指定成员的分数。</li><li>ZRANK key member: 返回有序集合中指定成员的排名（从小到大排序）。</li><li>ZREVRANK key member: 返回有序集合中指定成员的排名（从大到小排序）。</li><li>ZRANGE key start stop [WITHSCORES]: 返回有序集合中指定范围的成员，按照分数从小到大排序。</li><li>ZREVRANGE key start stop [WITHSCORES]: 返回有序集合中指定范围的成员，按照分数从大到小排序。</li></ul><div>有序集合类型在Redis中被广泛应用，例如排行榜系统、计分系统、优先级队列等。由于有序集合类型的成员唯一性和分数排序的特性，它可以方便地实现按照分数进行排名和范围查询的功能。</div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"064d1d46-229f-43b7-9dde-2290115533ca"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">set和zset的区别</span></p>","note":"<div><u>set</u>：<br><br></div><ul><li>集合中的元素是无序、不可重复的，一个集合最多能存储232-1个元素；</li><li>集合除了支持对元素的增删改查之外，还支持对多个集合取交集、并集、差集。</li></ul><div><u>zset</u>：<br><br></div><ul><li>有序集合保留了集合元素不能重复的特点；</li><li>有序集合会给每个元素设置一个分数，并以此作为排序的依据；</li><li>有序集合不能包含相同的元素，但是不同元素的分数可以相同。</li></ul>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"6580438c-63eb-4f68-8869-fa707708aed8"},"children":[]}]}]},{"data":{"text":"<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">reids持久化机制</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"5ddd09b3-c743-4403-982f-3a378d431de8"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">RDB（Redis DataBase）持久化</span></p>","note":"<div>Redis RDB（Redis DataBase）持久化是一种将内存中的数据保存到磁盘上的持久化方式。它将Redis的数据以二进制格式写入到磁盘上的RDB文件中，以便在Redis重新启动时可以将数据加载回内存，实现数据的持久化存储和恢复。</div><div>RDB持久化的特点和使用方式如下：</div><ol><li>触发方式：RDB持久化可以通过手动执行SAVE或BGSAVE命令，或者配置Redis在达到一定条件时自动执行持久化操作。</li><li>快照方式：RDB持久化是通过生成数据库的快照来实现的。在执行持久化时，Redis会将内存中的数据按照当前状态生成一个快照，然后将快照写入到磁盘上的RDB文件中。</li><li>数据一致性：RDB持久化是一个全量保存的过程，即在持久化时将数据库中的所有数据保存到RDB文件中。因此，在Redis重新启动时，可以完整地将数据加载回内存，实现数据的一致性和完整性。</li><li>文件压缩：RDB文件可以通过压缩算法进行压缩，以减少磁盘上的存储空间。</li><li>RDB文件恢复：当Redis重新启动时，可以通过加载RDB文件将数据恢复到内存中。Redis会读取RDB文件，并将其中的数据重新加载到内存中，从而恢复数据。</li><li>RDB文件的写入频率：可以通过配置Redis的SAVE选项或者设置触发自动持久化的条件来控制RDB文件的写入频率。</li></ol><div>使用RDB持久化有以下优点：</div><ul><li>性能较好：RDB持久化是将数据保存到磁盘上的一次性操作，相对于AOF持久化来说，具有更好的性能。</li><li>文件紧凑：RDB文件可以采用压缩算法进行压缩，相对于AOF文件来说，占用的磁盘空间更小。</li><li>适合备份和灾难恢复：RDB文件是一个完整的数据库快照，适合用于备份和灾难恢复。</li></ul><div>然而，RDB持久化也存在一些缺点：</div><ul><li>数据可能有丢失：由于RDB持久化是全量保存的方式，如果Redis发生故障或意外关闭，最后一次持久化之后的数据可能会丢失。</li><li>数据恢复较慢：由于RDB持久化是通过重新加载整个数据库快照来恢复数据，当数据量较大时，恢复过程可能较慢。</li><li>不适合实时数据同步：RDB持久化是定期触发的，无法实时同步数据的变化。</li></ul>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"eaf5e87f-3bcb-4fcc-9227-e7d70454f887"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">AOF（Append-Only File）持久化</span></p>","note":"<div>Redis AOF（Append-Only File）持久化是一种将Redis的操作日志以追加的方式写入到磁盘上的持久化方式。它以文本格式记录了所有对Redis数据的修改操作，包括写入操作、更新操作和删除操作等。通过回放AOF文件中的操作日志，可以重建数据集的状态，实现数据的持久化存储和恢复。</div><div>AOF持久化的特点和使用方式如下：</div><ol><li>触发方式：AOF持久化可以通过手动执行BGREWRITEAOF命令，或者配置Redis在达到一定条件时自动执行持久化操作。</li><li>操作日志记录：AOF持久化通过将每个写入操作追加到AOF文件末尾的方式记录操作日志。这意味着AOF文件是一个记录了所有写操作的日志文件。</li><li>数据恢复：当Redis重新启动时，会通过重新执行AOF文件中的操作日志来恢复数据。Redis会按照AOF文件的顺序逐条执行日志中的操作，从而恢复数据集的状态。</li><li>AOF重写：为了防止AOF文件过大导致性能下降，Redis提供了AOF重写机制。AOF重写会生成一个新的AOF文件，其中只包含了重建当前数据集状态所需的最少操作日志，从而减小AOF文件的体积。</li><li>文件同步：可以通过配置Redis的AOF持久化选项来控制AOF文件的同步频率，包括always、everysec和no三种模式，用于平衡数据安全性和性能之间的关系。</li></ol><div>使用AOF持久化有以下优点：</div><ul><li>数据更可靠：由于AOF持久化记录了所有写操作的日志，即使Redis发生故障或意外关闭，也可以通过回放AOF文件来恢复数据，数据的可靠性更高。</li><li>数据更完整：相对于RDB持久化来说，AOF持久化是逐条记录操作日志的，数据的变化更加完整，可以提供更精确的数据恢复。</li><li>实时数据同步：AOF持久化可以实时记录写操作的日志，因此可以提供更实时的数据同步机制。</li></ul><div>然而，AOF持久化也存在一些缺点：</div><ul><li>AOF文件较大：由于AOF文件是记录了所有写操作的日志，所以相对于RDB文件来说，AOF文件通常会更大，占用更多的磁盘空间。</li><li>AOF重写耗时：AOF重写操作可能会耗费较长的时间，并且在重写过程中会占用额外的系统资源。</li></ul><div>在使用AOF持久化时，可以根据实际需求来选择合适的持久化方式，或者结合RDB持久化来提供更可靠的数据保护方案。此外，Redis还提供了混合持久化的方式，可以同时使用AOF持久化和RDB持久化，以充分利用它们的优势。</div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"14dfcd4f-43d6-4cf3-a4aa-cc7a3be86dee"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">RDB-AOF混合持久化</span></p>","note":"<div>Redis混合持久化是指同时使用AOF（Append-Only File）持久化和RDB（Redis DataBase）持久化的方式。通过将两种持久化方式结合起来，可以充分利用它们各自的优点，并在数据恢复方面提供更灵活的选择。</div><div>在Redis的混合持久化方式中，可以按照以下方式进行配置和使用：</div><ol><li>开启AOF持久化：首先，需要在Redis配置文件中将AOF持久化功能打开，可以通过设置appendonly yes来开启。</li><li>配置AOF同步选项：可以根据需求配置AOF持久化的同步选项，包括appendfsync always、appendfsync everysec和appendfsync no。这些选项用于控制AOF缓冲区何时同步到磁盘，以平衡数据安全性和性能之间的关系。</li><li>配置AOF重写选项：为了避免AOF文件过大导致性能下降，可以配置AOF重写选项。通过设置auto-aof-rewrite-percentage和auto-aof-rewrite-min-size来触发自动进行AOF重写操作。</li><li>配置RDB持久化选项：可以根据需求配置RDB持久化的选项，包括设置RDB的保存路径和触发自动RDB持久化的条件等。</li><li>数据恢复时的选择：当Redis重新启动时，可以根据需要选择是使用AOF持久化还是RDB持久化来进行数据的恢复。可以通过配置文件中的appendonly选项来选择使用AOF持久化或通过执行redis-cli命令行工具中的BGRESTORE命令来加载RDB文件进行恢复。</li></ol><div>混合持久化的方式可以在数据恢复方面提供更灵活的选择。例如，可以使用AOF持久化实现实时数据同步和较高的数据安全性，同时使用RDB持久化进行定期的全量备份和灾难恢复。这样可以在确保数据的可靠性和完整性的同时，提供较好的性能和灵活性。</div><div>需要注意的是，混合持久化方式会增加系统的复杂性和资源消耗，同时也需要更多的磁盘空间来存储AOF文件和RDB文件。因此，在选择混合持久化方式时，需要根据实际需求和系统资源的限制进行权衡和配置。</div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"ebdc463b-3875-4a74-928e-5cdc41b98901"},"children":[]}]},{"data":{"text":"<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">reids单进程模型</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"96988e49-a482-46dd-bd0f-f266bd052de0"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">快的原因</span></p>","note":"<ol><li>Redis的网络IO和键值对读写是由一个线程来完成的。对服务端程序来说，线程切换和锁通常是性能杀手，而单线程避免了线程切换和竞争所产生的消耗；</li><li>Redis的大部分操作是在内存上完成的，这是它实现高性能的一个重要原因；</li><li>Redis采用了IO多路复用机制，使其在网络IO操作中能并发处理大量的客户端请求，实现高吞吐率。</li></ol>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"8e13d5b0-727d-41f6-b962-0ef91b2956f7"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">Redis在持久化时fork出一个子进程</span></p>","note":"<div><strong><br>1.5 Redis在持久化时fork出一个子进程，这时已经有两个进程了，怎么能说是单线程呢？<br></strong><br></div><div><strong>参考答案<br></strong><br></div><div>Redis是单线程的，主要是指Redis的网络IO和键值对读写是由一个线程来完成的。而Redis的其他功能，如持久化、异步删除、集群数据同步等，则是依赖其他线程来执行的。所以，说Redis是单线程的只是一种习惯的说法，事实上它的底层不是单线程的。<br><br></div><div><strong><br><br></strong><br></div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"e73d71fa-ff0a-495b-98ec-5a56cf4db1cd"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">IO多路复用</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"7ca05238-1a30-4f62-8bd2-086d16ba0fd9"},"children":[]}]},{"data":{"text":"<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">redis缓存淘汰策略</span></p>","note":"<div>Redis缓存淘汰策略是指在内存不足时，Redis用于决定哪些数据应该被淘汰（从内存中移除）以腾出空间给新的数据。以下是Redis中常见的缓存淘汰策略：</div><ol><li>LRU（Least Recently Used，最近最少使用）：根据数据最近被访问的时间来淘汰数据，即最久未被访问的数据优先被淘汰。</li><li>LFU（Least Frequently Used，最不经常使用）：根据数据被访问的频率来淘汰数据，即访问次数最少的数据优先被淘汰。</li><li>FIFO（First In, First Out，先进先出）：按照数据进入缓存的顺序来淘汰数据，即最早进入缓存的数据优先被淘汰。</li><li>Random（随机）：随机选择要淘汰的数据。</li><li>AllKeys-LRU（所有键中的LRU）：类似于LRU策略，但不仅仅是根据某个集合中的键最近的访问来选择淘汰的数据，而是从所有键中选择。</li></ol><div>Redis还提供了一些变种和组合策略，例如LRU近似算法（近似LRU）</div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"e05c3b38-6828-41f5-a8a7-938d15f9b301"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">LRU算法(Least Recently Used)-最近最少使用-淘汰最长时间</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"3995e4f9-64b8-4e86-ac40-ff36445eeb98"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">LFU算法(Least Frequently Used)--最不经常使用</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"2dddc41a-44d9-4a02-a9df-e186bec7923d"},"children":[]}]},{"data":{"text":"<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">redis分布式</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"0d7cc5d8-3b5b-4621-87fd-4f3d6c772a21"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">过期时间</span></p>","note":"<div><strong><br>你要如何设计Redis的过期时间？<br></strong><br></div><div><strong>参考答案<br></strong><br></div><ol><li>热点数据不设置过期时间，使其达到“物理”上的永不过期，可以避免缓存击穿问题；</li><li>在设置过期时间时，可以附加一个随机数，避免大量的key同时过期，导致缓存雪崩。</li></ol>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"bc6c9ddf-cf0a-4020-88ce-e2630afe1d38"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">分布式锁</span></p>","note":"<div><strong><br>Redis中，sexnx命令的返回值是什么，如何使用该命令实现分布式锁？<br></strong><br></div><div><strong>参考答案<br></strong><br></div><div>setnx命令返回整数值，当返回1时表示设置值成果，当返回0时表示设置值失败（key已存在）。<br><br></div><div>一般我们不建议直接使用setnx命令来实现分布式锁，因为为了避免出现死锁，我们要给锁设置一个自动过期时间。而setnx命令和设置过期时间的命令不是原子的，可能加锁成果而设置过期时间失败，依然存在死锁的隐患。对于这种情况，Redis改进了set命令，给它增加了nx选项，启用该选项时set命令的效果就会setnx一样了。<br><br></div><div>采用Redis实现分布式锁，就是在Redis里存一份代表锁的数据，通常用字符串即可。采用改进后的setnx命令（即set...nx...命令）实现分布式锁的思路，以及优化的过程如下：<br><br></div><div><u>加锁</u>：<br><br></div><div>第一版，这种方式的缺点是容易产生死锁，因为客户端有可能忘记解锁，或者解锁失败。<br><br></div><pre>setnx key value</pre><div>第二版，给锁增加了过期时间，避免出现死锁。但这两个命令不是原子的，第二步可能会失败，依然无法避免死锁问题。<br><br></div><pre>setnx key value\nexpire key seconds</pre><div>第三版，通过“set...nx...”命令，将加锁、过期命令编排到一起，它们是原子操作了，可以避免死锁。<br><br></div><pre>set key value nx ex seconds </pre><div><u>解锁</u>：<br><br></div><div>解锁就是删除代表锁的那份数据。<br><br></div><pre>del key</pre><div><u>问题</u>：<br><br></div><div>看起来已经很完美了，但实际上还有隐患，如下图。进程A在任务没有执行完毕时，锁已经到期被释放了。等进程A的任务执行结束后，它依然会尝试释放锁，因为它的代码逻辑就是任务结束后释放锁。但是，它的锁早已自动释放过了，它此时释放的可能是其他线程的锁。<br><br></div><div><br>想要解决这个问题，我们需要解决两件事情：<br><br></div><ol><li>在加锁时就要给锁设置一个标识，进程要记住这个标识。当进程解锁的时候，要进行判断，是自己持有的锁才能释放，否则不能释放。可以为key赋一个随机值，来充当进程的标识。</li><li>解锁时要先判断、再释放，这两步需要保证原子性，否则第二步失败的话，就会出现死锁。而获取和删除命令不是原子的，这就需要采用Lua脚本，通过Lua脚本将两个命令编排在一起，而整个Lua脚本的执行是原子的。</li></ol><div>按照以上思路，优化后的命令如下：<br><br></div><pre># 加锁\nset key random-value nx ex seconds \n\n# 解锁\nif redis.call(\"get\",KEYS[1]) == ARGV[1] then\n    return redis.call(\"del\",KEYS[1])\nelse\n    return 0\nend</pre>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"5f076ead-cbb3-4876-97d6-be189e378ebb"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">set key random-value nx ex seconds </span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"4f48e1da-6580-4683-9eec-19a56e5023e1"},"children":[]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">if redis.call(\"get\",KEYS[1]) == ARGV[1] then\r\n    return redis.call(\"del\",KEYS[1])\r\nelse\r\n    return 0\r\nend</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"a74647fd-920a-4ea8-84c4-a3e4995c4e3c"},"children":[]}]},{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">分布式广义session</span></p>","note":"<div><strong><br></strong>如果客户端第一次访问服务器，请求被分发到了服务器A上，则服务器A会为该客户端创建session。如果客户端再次访问服务器，请求被分发到服务器B上，则由于服务器B中没有这个session，所以用户的身份无法得到验证，从而产生了不一致的问题。<br><br></div><div>解决这个问题的办法有很多，比如可以协调多个服务器，让他们的session保持同步。也可以在分发请求时做绑定处理，即将某一个IP固定分配给同一个服务器。但这些方式都比较麻烦，而且性能上也有一定的消耗。更合理的方式就是采用类似于Redis这样的高性能缓存服务器，来实现分布式session。<br><br></div><div>从上面的叙述可知，我们使用session保存用户的身份信息，本质上是要做两件事情。第一是保存用户的身份信息，第二是验证用户的身份信息。如果利用其它手段实现这两个目标，那么就可以不用session，或者说我们使用的是广义上的session了。<br><br></div><div>具体实现的思路如下图，我们在服务端增加两段程序：<br><br></div><div>第一是创建令牌的程序，就是在用户初次访问服务器时，给它创建一个唯一的身份标识，并且使用cookie封装这个标识再发送给客户端。那么当客户端下次再访问服务器时，就会自动携带这个身份标识了，这和SESSIONID的道理是一样的，只是改由我们自己来实现了。另外，在返回令牌之前，我们需要将它存储起来，以便于后续的验证。而这个令牌是不能保存在服务器本地的，因为其他服务器无法访问它。因此，我们可以将其存储在服务器之外的一个地方，那么Redis便是一个理想的场所。<br><br></div><div>第二是验证令牌的程序，就是在用户再次访问服务器时，我们获取到了它之前的身份标识，那么我们就要验证一下这个标识是否存在了。验证的过程很简单，我们从Redis中尝试获取一下就可以知道结果。<br><br></div><div><strong><br></strong><br></div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"a12e021c-30e6-4335-acd9-442ea1870938"},"children":[]}]},{"data":{"text":"<p><span style=\"\n      color: #fff;\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 18px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">ElasticSearch</span></p>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"55082276-504e-4b2c-81de-f8d567dfd954"},"children":[{"data":{"text":"<p><span style=\"\n      color: rgb(30, 53, 86);\n      font-family: 微软雅黑, Microsoft YaHei;\n      font-size: 14px;\n      font-weight: noraml;\n      font-style: normal;\n      text-decoration: none\n    \">倒排索引</span></p>","note":"<div>Elasticsearch 使用一种称为倒排索引的结构，它适用于快速的全文搜索。一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，有一个包含它的文档列表。</div>","generalization":[],"richText":true,"expand":true,"isActive":false,"uid":"18977447-e4be-4aad-bff0-cad67b997984"},"children":[]}]}]},"theme":{"template":"classic4","config":{}},"layout":"verticalTimeline","config":{},"view":{"transform":{"scaleX":1,"scaleY":1,"shear":0,"rotate":0,"translateX":0,"translateY":0,"originX":0,"originY":0,"a":1,"b":0,"c":0,"d":1,"e":0,"f":0},"state":{"scale":1,"x":0,"y":0,"sx":-136,"sy":-270}}}